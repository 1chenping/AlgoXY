\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
\input{common.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Simulate epidemic by programming\\
通过编程模拟疾病的传染}

\author{刘新宇(Liu~Xinyu)
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline
  Tel:   +86-1305-196-8666 \newline}
  }

\markboth{Simulate epidemic by programming}
{Simulate epidemic by programming}

\maketitle

\ifx\wholebook\relax
\chapter{Simulate epidemic by programming}

\section{abstruct}
\else
\begin{abstract}
\fi

计算机对于复杂大系统的模拟很有帮助，这种模拟，或者叫仿真，不仅仅可以帮助我们
快速了解自然科学中的一些系统，例如复杂的粒子运动系统；还往往能够在一定程度上
能支持我们研究社会科学中的系统。本文通过编程来给出一个疾病传染的仿真示例，希望
能够给读者以启示。也算是对当前甲型H1N1流感的防治尽一些绵薄之力。

由于作者水平有限，文中难免有谬误之处，欢迎广大读者指正！
本文使用\LaTeXe排版，遵循FDL(GNU Free Documentation License)许可协议。
并受其保护。具体请参考：http://www.gnu.org/copyleft/fdl.html

\ifx\wholebook\relax\else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Epidemic simulation, Squeak, C++

{\bfseries Corresponding Author:} 刘新宇

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

%\begin{verse}
%子曰：学而不思则罔，死而不学则殆。%\\
%\end{verse}
%\begin{flushright}
%――《论语》
%\end{flushright}

%\begin{figure}[htbp]
%       \begin{center}
%	\includegraphics[scale=0.5]{images/peace.eps}
%        \caption{from www.zikai.org}
%       \end{center}
%\end{figure}

去年地震灾害的时候，我就常常问自己：“抗震救灾，一个普通的程序员能够做些什么？”。Google很快
给出了灾区的地图，各大网站及时报道救灾的新闻。可是对于普通程序员来说，如何才能发挥所长，尽
一份贡献呢？当前，正值甲型H1N1流感在世界蔓延，这个问题再次引起我的思考。

希望能通过这篇文章，尽我自己的一点绵薄之力。我将依次通过计算机程序给出一些直观的仿真结果，包括下面的几种情形：
\begin{itemize}
\item 传染病发生时，如果不采取任何防治措施的传播速度
\item 具有一定传播概率时的传播速度；
\item 公众自发防防治，主动采取隔离措施，及时治疗时的传播速度；
\item 带有一定潜伏期时的传播速度。
\end{itemize}

\section{method 1}
\label{method1}

\subsection{Kedama, a simple epidemic simulation example}

著名的Smalltalk程序员大岛芳树(Ohshima Yoshiki)曾经为squeak开发了一个叫做Kedama的项目。这个项目现在已经是
OLPC(one laptop per child)中Etoy的一部分。它可以非常直观的模拟疾病的流行\cite{kedama}, 西邮Linux兴趣小组
的同学们曾经帮助翻译了中文的介绍文章。下图是Kedama运行过程中的一幅截图：

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{images/kedama.eps}
        \caption{screen shot of kedama}
       \end{center}
\end{figure}

图中，黑色的方块表示一个封闭的区域。区域中一共有1000个点表示在其中自由运动的人，红色的点表示已经感染某种疾病的个体，
而绿色的点表示健康的个体。健康的个体如果接触到染病的个体就会被传染。Kedama的设计非常直观，其运行结果也非常惊人。
在完全自由运动的情况下，疾病在非常短的时间内感染了所有的人。

虽然Squeak和Etoy被设计为针对8到11岁的儿童学习使用，但是考虑到国内了解Smalltalk的人并不多。作者下面用C++来实现
一个类似的模拟。

首先是建模问题。其中一种建模的方法是采用简单的“暴力”解法，如果需要模拟一种疾病在1000个人中的传播，就开启1000个独立的
线程，每个线程代表一个人，并行在某区域内随机运动。其中一个线程被设置为已染病个体。每个线程在随机运动过程中，都检查和
自己遇到的其他人，是否已经染病。和染病线程接触后，自己就变成另一个染病线程。

这个方法，虽然看起来直观，然而却有两个问题难以解决。第一个问题是性能问题。虽然在现代的多核计算机上，同时开启多个线程
的性能已经大大提高，但是如果模拟人群的规模增大，例如模拟大型城市如北京、上海的上千万的人口，同时开启几千万的线程，这样
的计算，恐怕要使用超级计算机了。第二个问题是一个算法问题，也就是每个线程代表的人在独立运动中，如何判断自己和其他线程
代表的人接触到了？是否要在全体线程中做一个查找？如果是这样，完成某个人走一步，然后进行查找的算法为线性算法，其复杂度为$O(n)$，
n个线程的计算量为$O(n^2)$。这是非常大的计算量，算法的效率会非常低。

根据Kedama的启发，在做出一定的化简后，可以找到一个简单、高效的方法。假设需要在$W \times H$平方米的范围内，模拟
某种疾病在N个人中的传播。我们可以将区域划分为$W \times H$个格子，也就是每平方米一个格子。然后我们建立N个对象，放入
一个列表。每次模拟遍历一遍这个列表，让每个人独立走一步；同时，我们检查这个人是否染病，如果染病，我们就标记他所在的
那个格子（也就是那一位置所在的1平方米）为污染区。之后我们重新遍历这个列表一次，检查每个人所在的区域是否为污染区，如
果一个健康对象经过运动后进入了污染区，他就被标记为感染。我们的模拟程序不断重复上述的两步过程：移动――感染，直到90\%
的人染病后，程序退出。

下面我们来一步一步实现上述程序。首先是区域的建模，这部分非常简单。类定义如下：
\begin{lstlisting}
class area{
public:
  area(int w, int h):_width(w), _height(h){
    cells=new char[w*h];
    reset();
  }
  virtual ~area(){ delete cells; }

  int width(){ return _width; }
  int height() { return _height; }

  char* at(int x, int y){
    return cells+y*_width+x;
  }

  void reset(){ memset(cells, 0, _width*_height); }

private:
  int _width;
  int _height;
  char* cells;
};
\end{lstlisting}

其中cells是一个buffer，其实代表的是w列、h行的二维格子，我们将用它来标记污染区。之所以
采用原始的buffer，是出于效率考虑。我们可以通过memset和随机访问操作。快速地重置污染区
和访问污染区。

之后需要对人进行建模，对于在疾病传播模拟程序中的人，我们只关心两个方面：1，他是否染病？2，他
目前在哪里，向那个方向以多快速度进行运动？对于1，我们可以以一个bool量来代表；对于2，我们
需要对位置和运动信息建模。这一模型如下:

\begin{lstlisting}
const int  MAX_SPEED = 50; // walking speed: 50 [m/min]
struct physics{
  physics(){}
  physics(int _x, int _y, int _s, int _d):x(_x), y(_y), 
      speed(_s), direction(_d){}
  physics(const physics& p):x(p.x), y(p.y), 
      speed(p.speed), direction(p.direction){}
  physics& operator=(const physics& p){
    x=p.x; y=p.y;
    speed=p.speed; direction = p.direction;
  }

  bool operator==(const physics& p){
    return x==p.x && y==p.y && speed== p.speed && 
           direction == p.direction;
  }

  void move(double dt){
    x+=static_cast<int>(static_cast<double>(speed)*dt*
             cos(static_cast<double>(direction)/180.0*pi));
    y+=static_cast<int>(static_cast<double>(speed)*dt*
             sin(static_cast<double>(direction)/180.0*pi));
    speed = rand() % MAX_SPEED;
  }

  int x;
  int y;
  int speed;
  int direction;
};
\end{lstlisting}

物理量包括位置坐标x,y，以及运动的速率speed和运动的方向direction（本程序中使用角度）。定义拷贝构造函数，复制以及相等
是为了方面操作。其中值得注意的是运动函数move，它接受一个运动时间小量dt，然后在二维平面上以当前的运动速度和方向更新位置，
最后再更新运动速率。考虑到人在步行时的运动速率为3km/h，我们的最大速率设置为50m/min。

有了物理运动信息，接下来就可以定义被模拟的人了：

\begin{lstlisting}
class person{
public:
  person(bool x=false):_infected(x){}
  person(const person& p):_infected(p._infected), _loc(p._loc){}
  person& operator=(const person& p){
    _infected = p._infected;
    _loc = p._loc;
    return *this;
  }

  physics location() const{ return _loc; }
  void set_location(const physics& l){ _loc=l; }
  bool infected() const { return _infected; }
  void set_infected(bool x) { _infected = x; }

  void move_inside(area& a, double dt){
    _loc.move(dt);
    if(_loc.x<0 || _loc.x>a.width())
      _loc.direction = (180 - _loc.direction + 360) % 360;
    if(_loc.y<0 || _loc.y>a.height())
      _loc.direction = (-_loc.direction + 360) % 360;
    if(_loc.x<0)
      _loc.x=-_loc.x;
    if(_loc.x>a.width())
      _loc.x=2*a.width()-_loc.x;
    if(_loc.y<0)
      _loc.y=-_loc.y;
    if(_loc.y>a.height())
      _loc.y=2*a.height()-_loc.y;
  }

private:
  bool _infected;
  physics _loc;
};
\end{lstlisting}

这段定义中，除了构造、拷贝、赋值以及getter/setter之外，只有一个move\_inside函数，
它是模拟人在某区域运动的关键函数。该函数接受一个区域引用和一个时间小量。然后调用前面
定义的move函数更新物理信息。如果发现人已经运动出所限制的区域。程序按照物理上弹性碰撞
的规律，将人限制回区域内，并让他的运动根据弹性反向。读者也可以不采用弹性碰撞，而使用
其他物理模型。

模拟程序的核心，是一个被称为scheduler的类。之所以起这个名字，是因为它的运行上，本质
类似于一个调度器――一次取出列表中的每个人，然后让其运行\cite{ao}。首先它被设计为一个
sigleton：
\begin{lstlisting}
class scheduler{
public:
  static scheduler& inst(){
    static scheduler _inst;
    return _inst;
  }
  //...

private:
  scheduler(){}
  ~scheduler(){ 
    delete a; 
    for(Population::iterator it=people.begin(); it!=people.end(); ++it)
      delete *it;
  }

  area* a;
  typedef std::list<person*> Population;
  Population people;
  int n_infected;
  std::list<int> diagram;
};
\end{lstlisting}

scheduler拥有一个指向模拟区域的指针a，一个记录全体被模拟人口的列表people。一个记录已染病人数
的变量n\_infected，和一个用于将模拟结果写入文件的列表diagram。scheduler在最后析构时会释放
所有被模拟人的对象。这里之所以没有采用person对象的列表，而采用了person指针的列表。是因为在语义
上，我们并不关心不同个体的差异。我们并不能说，在同一位置，以同一速度运动的不同对象是相等的，因为
他们完全可以是不同的人。

scheduler在初始化时，设置好区域，创建出n-1个健康个体和一个染病个体。然后把它们随机放入区域中
的各种位置。并设置目前的染病人口数为1。

\begin{lstlisting}
const bool INFECTED = true;
class scheduler{
  //...

  void setup(int w, int h, int n){
    a=new area(w, h);
    for(int i=0; i<n-1; ++i)
      people.push_back(new person());
    people.push_back(new person(INFECTED));
    put_people(people, *a);
    n_infected = 1;
  }

  //...
private:
  template<class Coll>
  void put_people(Coll& coll, area& a){
    for(typename Coll::iterator it=coll.begin(); it!=coll.end(); ++it){
      (*it)->set_location(physics(rand()%a.width(), rand()%a.height(),
                                  rand()%MAX_SPEED, rand()%360));
    }
  }
\end{lstlisting}

scheduler的核心函数是run()，它按照我们最初设计的算法，每次遍历全部人口，执行移动――感染两个步骤，
为了直观，函数还在每次模拟后，显示输出当前时间（单位是分钟），在总人口中有多少人已染病。并在diagram
列表中，记录染病人数随时间变化的曲线。当90\%的人口染病后，程序退出。

\begin{lstlisting}
class scheduler{
  //...

  void run(){
    for(int tm=0; n_infected < people.size()*90/100; tm++){
      a->reset();
      move();
      infect();
      std::cout<<"time "<<tm/60<<":"<<tm%60<<" "
               <<n_infected<<"/"<<people.size()<<" are infected\r";
      diagram.push_back(n_infected);
    }
    write_diagram();
  }
\end{lstlisting}

移动――感染的两个函数分别由move()和infect()实现。移动步骤遍历全部人口，针对每个人，调用move\_insdie()
函数；如果当前个体已被感染，则标记他所在的位置为污染区（设置为1）。然后在感染步骤中，程序再次遍历全部人口，
针对每个健康人，如果他所在的区域已经污染，则将此人标记为患病；并增加染病人口数量。

\begin{lstlisting}
const double dt = 1;       // 1 min
class scheduler{
  //...
private:
  void move(){
    for(Population::iterator it=people.begin(); it!=people.end(); ++it){
      (*it)->move_inside(*a, dt);
      if((*it)->infected())
        *(a->at((*it)->location().x, (*it)->location().y))=1;
    }
  }

  void infect(){
    for(Population::iterator it=people.begin(); it!=people.end(); ++it)
      if(*(a->at((*it)->location().x, (*it)->location().y))){
        n_infected += (*it)->infected()?0:1;
        (*it)->set_infected(true);
      }
  }

  void write_diagram(){
    std::ofstream file("diagram.csv");
    std::copy(diagram.begin(), diagram.end(), 
       std::ostream_iterator<int>(file, "\n"));
  }
};
\end{lstlisting}

我们注意到，这个算法在每一步的运算复杂度为$O(n)$，而非$O(n^2)$。程序最后使用STL的copy算法和insert iterator
将染病人口随速度变化的曲线写入一个csv文件，供我们使用Excel进行后继分析。

程序的主函数main非常简单：
\begin{lstlisting}
int main(int argc, char** argv){
  //Beijing has people density as 888 persons/km^2, 
  //==> 1061 m^2 is the best fit
  scheduler::inst().setup(1061, 1061, 1000);
  scheduler::inst().run();
}
\end{lstlisting}

为了接近真实情况，考虑到北京市的人口密度为888人/平方公里，如果样本人群为1000，在1061米长1061米宽的区域内模拟
即可。程序最后输出：

\begin{verbatim}
time 124:34 900/1000 are infected
\end{verbatim}

结果非常惊人！虽然只有一个人染病，但是仅仅过了124小时后，就有9成的人群被感染。如果考虑到人群旨在白天活动8小时，则
在不进行任何防护措施的情况下，接触即传染的疾病仅仅需要2周，就可以使城市中的9成人口感染。这就是为什么在古代，瘟疫可以
迅速消灭一个城市。

我们用Excel将染病曲线绘制出来，如下：

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{images/epidemic-free.eps}
        \caption{infected people along time}
       \end{center}
\end{figure}

这是一个标准的指数曲线。也就是说，在无任何防控措施的情况下，传染病会以指数速度进行传播。

% ================================================================
% epidemic with possibility factor
% ================================================================
\section{epidemic with probability factor}
\label{p-factor}

上一模型中存在一些不合理的地方，比如假设健康的个体接触患病者就会被感染。这一假设对于恶性传染病，例如鼠疫等可能
比较适用。但是对于甲型H1N1流感，可能就过于粗放。为此我们可以增加一传染概率来改进模型。所谓传染概率，也就是并非
接触即被传染，而是有一定的概率被传染。影响这一概率的因素很多，例如健康个体的身体状况，是否正面接触等等。

根据这一模型，我们可以修改当前程序如下。

\begin{lstlisting}
  void infect(){
    for(Population::iterator it=people.begin(); it!=people.end(); ++it)
      if(!(*it)->infected() &&
         *(a->at((*it)->location().x, (*it)->location().y))&&
         rand()%100 > INFECT_PROBABILITY){
        n_infected++;
        (*it)->set_infected(true);
      }
  }
\end{lstlisting}

这一改进在infect()函数中。在遍历全部人口中，如果当前的个体是健康个体，他走入了污染区，并且感染概率超过预设的
INFECT\_PROBABILITY，就标记此人被感染，并增加爱感染个体数量。当此阈值被设置为50\%时，程序执行结果如下：

\begin{verbatim}
time 272:3 900/1000 are infected
\end{verbatim}

可以发现，加入感染概率模型后，疾病传染速度明显降低。大致需要272小时才能使9成人口感染。我们使用Excel打开CSV
文件，显示曲线如下：

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{images/epidemic-probability.eps}
        \caption{epidemic speed with infect probability}
       \end{center}
\end{figure}

可以看出，虽然速度比第一个模型减慢了。但是曲线形状仍然是指数形状。这个结果告诉我们，即使不是恶性传染病，传染
速度仍然是惊人的。

% ================================================================
%                 hospital model
% ================================================================
\section{Hopspital model} \label{hospital-model}

% ================================================================
%                 Others & summary
% ================================================================
\section{Other methods and Summary}
不枚举所有的排列而直接计算结果还有其他思路。Alecs King(alecs@perlchina.org)在TopLanguage讨论组给出了一个特别优美的实现

\begin{lstlisting}
get ab = sum $ foldl f [1] ab
    where f last 'A' = scanl (+) 0 last
          f last 'B' = scanr (+) 0 last 
\end{lstlisting}

%$
作为本文的结束，作者在此给出这个解法的一个简短分析。这一分析类似于数学归纳法，但是并不严格。

首先是平凡情况，如果AB串的长度为0,则符合条件的英文串只有一个，就是小写英文字母a；

如果长度为m的AB串，符合条件的英文串可以写成$x_1,x_2,x_3,...,x_{m+1}$的形式，
假设在这m+1个位置，放置第m+1个英文字母的方案数依次为：$n_1,n_2,n_3,...,n_{m+1}$。则符合要求的英文串总数就等于
$n_1+n_2+n_3+...+n_{m+1}$。
现在考虑长度为m+1的AB串，也就是在刚才长度为m的AB串后面，增加一条“前后规则”$X$，那么放置第m+2个英文字母的方案数可以这样求出：
\begin{itemize}
\item 如果$X=A$，也就是新字母要放在上一个字母的后面，首先考虑放在起始位置，显然这是不可能的，因为这样一来新字母就只可能处在上一字母的前面了；
再考虑左数第2位置，如果上一字母放在左数第1位置的方案数是$n_1$，则新字母放在第2位置的方案数也是$n_1$，因为只要把新字母紧接着上一个字母放就可以了；
再考虑左数第3位置，如果上一字母放在左数第2位置的方案数是$n_2$，则新字母放在第3位置的方案数就是是$n_1+n_2$，也就是上一字母放在第1，第2方案数的和；
...
所以总方案数为$0+n_1+(n_1+n_2)+(n_1+n_2+n_3)+...+(n_1+n_2+...+n_{m+1})$。
\item 如果$X=B$，也就是新字母要放在上一个字母的前面，首先考虑放在最右侧位置，显然这是不可能的，因为这样一来新字母就值可能处在上一字母的后面了；
再考虑右数第2位置，如果上一字母放在倒数第1位置的方案数是$n_{m+1}$，则新字母放在倒数第2位置的方案数也是$n_{m+1}$，因为只要把新字母紧接着放在上一个字母前就可以了；
分析基本同上，只不过要从右侧开始，所以所以总方案数为$(n_1+n_2+...+n_{m+1})+(n_1+n_2+...+n_m)+...+n_{m+1}+0$。
\end{itemize}
将这一分析翻译成Haskell就是上面的代码。

至此本文给出了解决这一问题的三种方法，其中第一种穷举法虽然效率很差，但是特别直观，可以用来验证其他方法的正确性；第二种生成法减少了计算的次数，但是仍然需要枚举出
所有的子方案。第三种方法通过展开方案树的形式，可以直接计算而不枚举方案。最后还给出了一种递推的思路。作者窃以为，解决了一个问题而并不满足，不断深入探索的过程特别
有意义，并且趣味性很强。同样语言本身的特性有时候能够帮助程序员从繁冗的部分解脱出来而把更多关注放在问题本身上。无论是C++标准库还是Haskell优雅的语用都有助于解题
的思维。由于作者水平有限，文中错误想必不少，还望读者批评指正。

\begin{thebibliography}{99}

\bibitem{kedama}
Oshima Yoshiki. Kedama: A massively-parallel tile-scriptable particle system. http://www.is.titech.ac.jp/~ohshima/squeak/kedama/

\bibitem{ao}
Liu Xinyu. 
\bibitem{kedama_cn}
，《程序设计中的组合数学》，清华大学出版社, Feb. 2001

\bibitem{AnnotatedSTL}
候捷，《STL源码抛析》，华中科技大学出版社，2002年6月

\bibitem{sgiSTL}
http://www.sgi.com/tech/stl/

\bibitem{iota}
http://www.knowledgerush.com/kr/encyclopedia/APL\_programming\_language/

\end{thebibliography}

\ifx\wholebook\relax\else
\end{document}
\fi
