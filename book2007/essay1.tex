\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
\input{common.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Lambda and high order function (I)\newline
       会当凌绝顶（上）}

\author{刘新宇(Liu~Xinyu)
\thanks{{\bfseries Liu Xinyu } \newline
  Ting Yu Xuan \newline
  5-2-201, ShiZiPo, Xi, DongZhiMenWai, DongCheng district, Beijing, 200027, P.R.China \newline
  Email: liuxinyu95@gmail.com \newline
  Tel:   +86-1305-196-8666 \newline
  Fax:   N.A. \newline}
  }

\markboth{Lambda and high order function, Jan, 2007}
{Lambda and high order function, Jan, 2007}

\maketitle

\ifx\wholebook\relax
\chapter{Lambda and high order function (I)}

\section{abstruct}
\else
\begin{abstract}
\fi

简单重复是人们最不喜欢的一件事情，《摩登时代》中的大机器流水线能够很快使一
个正常人疯狂――简单的重复劳动就是其中的原因之一。消除重复的手段之一就是制造
工具，让工具来代替人，去应对重复的工作。在软件开发中，抽象就是一种工具。
每向上抽象一个层次，就如同“更上一层楼”，眼前的景观会豁然开朗。眼界会从
“鳞次栉比”街巷，开阔为“大漠孤烟直，长河落日圆”般壮观的景象。本文就通过
分析日常开发中琐碎的代码，不断抽象，给出高阶函数和Lambda的概念。

由于作者水平有限，文中难免有谬误之处，欢迎广大读者指正！
本文使用\LaTeXe排版，遵循FDL(GNU Free Documentation License)许可协议。
并受其保护。具体请参考：http://www.gnu.org/copyleft/fdl.html

\ifx\wholebook\relax\else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Lambda, High oder function, C++

{\bfseries Corresponding Author:} 刘新宇

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

\begin{verse}
岱宗夫如何？齐鲁青未了。\\
造化钟神秀，阴阳割昏晓。\\
荡胸生层云，决眦入归鸟。\\
会当凌绝顶，一览众山小。
\end{verse}
\begin{flushright}
――杜甫《望岳》
\end{flushright}

\begin{figure}[htbp]
	\includegraphics[scale=0.75]{images/mount_tai.eps}
\end{figure}
孔子登东山而晓鲁，登泰山而晓天下。平日生活在城市水泥森林中的人，举目只能看到“咫尺蓝天”，
整日为日常琐事所系，天长日久，难免作了“井底之蛙”。编写程序也是如此，如果终日沉浸于代码，
就难免“学而不思则罔”。本文将从极为熟悉的日常程序开始，尝试从程序的水泥森林中走出来，
登高远望，体会“一览众山小”的爽朗感觉。
首先看三段比较常见的代码\cite{sicp}：

\lstset{language=C++, 
  frame=single,
  showstringspaces=false, 
  breaklines=true, 
  breakautoindent=true}

\begin{lstlisting}
int sumInt(int a, int b){
	int res=0;
	for(int i=a; i<=b; ++i)
		res+=i;
	return res;
}

int sumCube(int a, int b){
	int res=0;
	for(int i=a; i<=b; ++i)
		res+= i*i*i;
	return res;
}

double sumPi(int a, int b){
	double res=0;
	for(int i=1; i<=b; i+=4)
		res+= 1/(static_cast<double>(i)*static_cast<double>(i+2));
	return res;
}
\end{lstlisting}

这三个函数表面不同，然而形式上却极为相似。好像填词，虽然是不同的内容，只要词牌一样，就有一
致的形式。看到“明月几时有，把酒问青天”，知道是《水调歌头》，看到“才饮长沙水，又食武昌鱼”也
知道是《水调歌头》，虽然内容不同，然而形式却一致。

这三段程序都是用来求累加，它们分别计算如下的序列的和：

\be
  1+2+3+\ldots = \sum_{i=1}^n i \label{sum-int}
\ee
\be
  1^3+2^3+3^3+\ldots = \sum_{i=1}^n i^3 \label{sum-cube}
\ee
\be
  \frac{1}{1 \cdot 3} + \frac{1}{5 \cdot 7} + \frac{1}{9 \cdot 11} + \ldots = \sum_{i=1}^n \frac{1}{(2i-1)(2i+1)} \label{sum-pi}
\ee

并且其中第3个序列会收敛到$\pi/8$。

对于计算机程序，这种类似还不仅仅停留在形式上，类似意味着抽象，意味着一旦加以归纳，以后就可以不必重复劳动，意味着减小了重复工作中出现错误的风险。为此将上述代码抽象为如下形式：

\begin{lstlisting}
<sum-func>(<a>, <b>){
	res(0);
	for(i=a; i<=b; <next>(i))
		res+=<func>(i);
	return res;
}
\end{lstlisting}

凡是涉及用户定制的部分都用$<>$包括起来，这样的统一形式显然不能直接工作，最多可可以作为一个copy-past用的模板。而这样依然不能保证减小重复工作中出现错误的风险。为此可以设法将其抽象为合法的C++代码。这里的难点在于，型别的不确定性，在抽象阶段还无法确定$<a>$和$<b>$的型别以及$<sum-func>$和$<func>$返回值的型别。C++作为静态强类型语言，其型别系统也是一个双刃剑。某些情况下在动态类型语言中轻而易举的功能，在强型别系统中却非常困难实现。对于当前的问题，暂时可以使用C++模板对型别加以抽象，如下：

\begin{lstlisting}[frame=single]
template<class T, class F, class G>
T sumGeneric(T a, T b, F func, G next){
	T res(0);
	for(T i=a; i<=b; next(i))
		res += func(i);
	return res;
};
\end{lstlisting}

这段代码，允许用户将循环体内计算的过程func()和用于从a向b前进的过程next()以参数的形式传递进入程序，然后按照抽象的形式加以计算。这种参数传递不关心func()和next()的具体类型。只要他们能够以函数的形式加以调用就可以\footnote{这里并不严格地做了一种类型上的假设：输入参数a和b以及该程序的返回值是同一种类型。这一假设在这里可以简化程序的实现，但是并不通用。}。这种方式正是Andrei在《Modern C++ Design》中给出的Plocy based programming概念\cite{moderncpp}。

既然该通用的加法程序不关心func和next的类型，只要他们能够以 func(x) 和 next(x) 的形式加以
调用就可以。因此就可以采用非常轻量级的方法实现它们，传统的方法是使用函数指针，当然也可以
采用C++提供的functor。下面是针对本文最开始列出的三段代码所实现的功能，给出的一些具体实
现。他们都是functor。

\begin{lstlisting}
template<class T>
struct Self{
	T operator()(T x) { return x; }
};

template<class T>
struct Cube{
	T operator()(T x) { return x*x*x; }
};

template<class T>
struct MyFunc{
	T operator()(T x){
		return 1/(x*(x+2));
	}
};

template<class T>
struct Inc{
	void operator()(T& x){ ++x;}
};

template<class T>
struct Inc4{
	void operator()(T& x){ x+=4;}
};
\end{lstlisting}

这些实现中，Self, Cube和MyFunc，都是对自变量x的某种变换，其中Self不对自变量x做任何改变而直接返回x；
Cube返回自变量x的三次方；而MyFunc会将自变量x和x+2相乘后取倒数。Inc和Inc4不同于前三个函数，
他们会改变x的值。所有这些函数单元都不关心自变量的具体类型。

通过上述抽象后，就可以对比一下使用泛化的累加函数的效果，测试代码如下：

\begin{lstlisting}
cout<< "======trivial func calls========\n";
cout<< "sum int 1..100="<<sumInt(1, 100)<<endl;
cout<< "sum cube 1..100="<<sumCube(1, 100)<<endl;
cout<< "sum to PI 1..100="<<8.0*sumPi(1, 100)<<endl;

cout<< "======high order sum calls======\n";
cout<< "sum int 1..100=" <<sumGeneric(1, 100, Self<int>(), Inc<int>()) <<endl;
cout<< "sum cube 1..100=" <<sumGeneric(1, 100, Cube<int>(), Inc<int>()) <<endl;
cout<< "sum to PI 1..100=" <<8.0*sumGeneric(1.0, 100.0, 
    MyFunc<double>(), Inc4<double>()) <<endl;
\end{lstlisting}

上面这段程序会输出：
\begin{verbatim}
=============trivial func calls==============
sum int 1..100=5050
sum cube 1..100=25502500
sum to PI 1..100=3.12159
=============high order sum calls==============
sum int 1..100=5050
sum cube 1..100=25502500
sum to PI 1..100=3.12159
\end{verbatim}

可见，通用的累加函数可以达到同样的效果。但是却更加灵活了。用户可以根据自己的要求，方便的写出$<func()>$和$<next()>$。然后以参数的形式传递给sumGeneric，从而达到自己的要求。在数学上，通常称这种以其它函数作为自变量的函数，（也就是函数的函数）为高阶函数\footnote{这里叙述的是一种不严格的定义，读者可以参考泛函分析的书籍了解严密的定义}。

在本文上半部分的后继内容中，将在第\ref{problems}节中，针对现有的实现找出其存在的问题。然后依次解决它们。并在第\ref{lambda}节中引出lambda演算的概念。解决这些问题后，将在本文下半部分进一步
探询相等的本质，进而在给出丘奇数的思路。最后全篇以简要介绍Y-combinator作为结尾。

% ================================================================
%                 Problems
% ================================================================
\section{Problems}
\label{problems}

\subsection{What can be better?}

上面给出的高阶函数sumGeneric()，虽然进行了一定程度的抽象，但仍然存在一些问题，主要包括下面三个：
\begin{enumerate}
\item 对于编译期编程（模板推导，也就是所谓的template meta programming）是否存在高阶函数？
\item 高阶函数到底有何用处，能够带来哪些好处？
\item \ref{introduction}为了使用高阶函数，用户不得不提供自己的Inc, Inc4, Self, Cube和MyFunc，明显可以看出这样的functor数量众多，内容简单，分布于程序的各处，并且不易维护；有时甚至很难命名\footnote{例如MyFunc，读者看到这个名字根本无法想想它是干什么的，还不如干脆叫$1/(2n-1)(2n+1)$看起来明白}。functor爆炸的问题怎么解决？
\end{enumerate}

\subsection{high order template meta programming functions}
在编译期编程中，由于不能定义任何编译期变量，所以是一种纯函数式的编程\cite{scheme_cpp}。编译期编程目前只能处理类型量和整形量，所以暂时无法处理$\pi/8$这样的级数累加序列。下面的两段程序分别处理两种不同的累加：

\begin{lstlisting}[frame=single]
template<int a, int b>
struct SumInt{
	static const int value = a + SumInt< a+1, b>::value;
};

template<int b>
struct SumInt<b, b>{ static const int value = b; };

template<int a, int b>
struct SumCube{
	static const int value = a*a*a + SumCube< a+1, b>::value;
};

template<int b>
struct SumCube<b, b>{ static const int value = b*b*b; };
\end{lstlisting}

由于编译期编程的判断语句主要通过模板偏特化进行实现，所以SumInt和SumCube分别定义了累加用的出口。
采用下面的调用方法，就可以输出和前面同样的结果：

\begin{lstlisting}[frame=single]
std::cout<<"sum int 1..100="<<SumInt<1, 100>::value<<"\n";
std::cout<<"sum cube 1..100="<<SumCube<1, 100>::value<<"\n";
\end{lstlisting}

对于这类编译期程序，也可以进一步抽象，定义高阶累加程序，为此把上面两段非常类似的代码中不同的部分用概括起来，就得到了下面的高阶函数代码：

\begin{lstlisting}[frame=single]
template<int a, int b, template<int> class Func>
struct SumGeneric{
	static const int value = Func<a>::value + SumGeneric< a+1, b, Func>::value;
};

template<int b, template<int> class Func>
struct SumGeneric<b, b, Func>{ static const int value = Func<b>::value; };
\end{lstlisting}

为了使用这个编译期高阶过程，还必须提供用于自然数相加和自然数平方相加的函数，作为Func注入SumGeneric中。

\begin{lstlisting}[frame=single]
template<int x>
struct SelfTrans{
	static const int value = x;
};

template<int x>
struct CubeTrans{
	static const int value = x*x*x;
};
\end{lstlisting}

这两个函数都非常简单，调用时，只要把SelfTrans和CubeTrans作为第三个模板参数传入即可，调用代码如下：
\begin{lstlisting}[frame=single]
std::cout<<"sum int 1..100="<<SumGeneric<1, 100, SelfTrans>::value<<"\n";
std::cout<<"sum cube 1..100="<<SumGeneric<1, 100, CubeTrans>::value<<"\n";
\end{lstlisting}

运行结果也是5050和25502500。

\subsection{The power of high order function}

下面回答“高阶函数有什么用”的问题。简单看来，高阶函数好像仅仅是一组类似函数的抽象。但是在某些场合下，只有利用高阶函数才能完成相应的功能。例如假设需要通过利用累加的数值计算方法实现定积分的计算。这一计算过程可以表达如下：

\bea
  && \int_a^b f(x) dx = f(a)dx + f(a+dx)dx + f(a+2dx)dx + \cdots \nonumber \\
  && = [f(a) + f(a+dx) + f(a+2dx)]dx
\eea

其中dx是某一非常小的分隔距离，利用前面的高阶函数可以方便的实现定积分的数值计算。
方法是将next定义为每次前进dx，
func实现为被积函数，上下限分别对应a和b。例如下面的程序实现了一个积分函数。

\begin{lstlisting}[frame=single]
template<class Func>
double integral(Func f, double a, double b, double dx){
	struct Inc_dx{
		Inc_dx(double dx):_dx(dx){}
		void operator()(double& x){
			x+=_dx;
		}
	private:
		double _dx;
	};
	return dx*sumGeneric(a, b, f, Inc_dx(dx));
}
\end{lstlisting}


这个函数接受4个参数，被积函数f,积分上下限a和b，以及分隔区间dx。该函数内部首先定义了一个局部functor\footnote{目前的C++各个实现中，对函数作用域内部的类或者内部类模板的支持不尽相同，有些C++中尚且不能实现scheme中类似local的内部环境，因此在这类环境中，Inc\underline{ }dx()无法直接访问dx，为此本例中采用带参数的构造函数方法，将dx传入其中。}，
名字叫Inc\underline{ }dx()，然后integral调用sumGeneric将积分计算出来。
下面是采用此积分程序计算$xdx$和$x^3dx$以及$sin(x)dx$定积分的实例：

\begin{lstlisting}[frame=single]
struct Sin{
	double operator()(double x){ return sin(x); }
};
const double PI=3.1415927;

std::cout<<"Int xdx (0~4)= 0.5x^2 (0~4)="<<integral(Self<double>(), 0.0, 4.0, 0.001)<<"\n";
std::cout<<"Int x^3dx (0~4)= 0.25x^4 (0~4)="<<integral(Cube<double>(), 0.0, 4.0, 0.001)<<"\n";
std::cout<<"Int sin(x)dx (0~pi/2)= "<<integral(Sin(), 0.0, PI/2, 0.001)<<"\n";
\end{lstlisting}

由于这几个积分非常简单，因此可以方便验证程序输出的正确与否：
\begin{verbatim}
Int xdx (0~4)= 0.5x^2 (0~4)=8.002
Int x^3dx (0~4)= 0.25x^4 (0~4)=64.032
Int sin(x)dx (0~pi/2)= 0.999704
\end{verbatim}

除了计算定积分外。这类高阶函数还可以应用在大量的非数值计算的场合。例如下面的两种实际应用，表面看起来似乎没有什么关联：
\begin{enumerate}
\item 将一组华氏温度转换为摄氏温度；
\item 将一组员工名单中的员工姓氏列出来；
\end{enumerate}

这两个应用的程序都非常容易实现。但是仔细观察这两个看似无关的应用，却可以发现有一些共同的内容。首先它们都针对一组数据进行处理；其次，它们的结果仍然是一组数据；最后，它们都是对要进行处理的数据进行某种变换（华氏变换成摄氏，员工姓名变为姓氏）。为此可以根据这种抽象定义出一个高阶函数transform，如下：

\begin{lstlisting}[frame=single]
template<class List, class Func>
List* transform(List* alist, Func f){
	if(!alist)
		return 0;	//null
	else
		return cons( f(alist->first), transform(alist->rest, f) );
}
\end{lstlisting}

为了增加趣味性，本文没有采用stl的任何容器类工具来代表一组数据，而采用了最为朴素的单向链表作为数据结构。transform程序接受这样一组数据（一个链表）和一个用户变换的函数f。然后该程序首先检查这组数据是否是空，若为空则什么都不做，直接返回0（也就是空指针）；反之，该程序从链表中取出第一个数据，然后应用f进行变换，将变换的结果和针对后继链表内容的变换，合成最终的结果并返回。很明显这是一个递归程序。

该程序使用的链表数据结构和用户构造链表的cons函数分别定义如下：
\begin{lstlisting}[frame=single]
template<class T>
struct List{
	List(const T& x, List<T>* y): first(x), rest(y){}
	~List(){ delete rest; }

	T first;
	List* rest;
};

template<class T>
List<T>* cons(const T& x, List<T>* y){
	return new List<T>(x, y);
}
\end{lstlisting}

有了transform高阶函数和通用数据结构，就可以非常容易的实现上面的两个应用问题。首先是华氏温度转换为摄氏温度。为此仅仅定义一个特定的转换函数，并将其作为参数传入transform就可以了。下面是测试程序。

\begin{lstlisting}[frame=single]
struct FtoC{
	double operator()(double x){ return (x-32)*100/(212-32); }
};
List<double>* flist = cons(200.0, cons(10.0, cons(85.0, cons(20.0, cons(15.0, cons(32.0, static_cast<List<double>*>(0)))))));
List<double>* clist = transform(flist, FtoC());
\end{lstlisting}

为了打印出测试结果，还需要某个程序能够将list的内容打印出来，下面是一个通用打印程序，它接受一个list，如果这个list是空，则仅仅打印一个换行，否则该程序先将list中第一个元素的值打印出来，然后再递归调用打印剩余的部分：

\begin{lstlisting}[frame=single]
template<class List>
void printList(List* alist){
	if(alist == 0)
		std::cout<<"\n";
	else{
		std::cout<<alist->first<<", ";
		printList(alist->rest);
	}
};
\end{lstlisting}

使用此printList程序，就可以观察前面的华氏温度转化为的摄氏温度结果，调用方法为：

\begin{lstlisting}[frame=single]
printList(clist);
\end{lstlisting}

程序输出：

\begin{verbatim}
93.3333, -12.2222, 29.4444, -6.66667, -9.44444, 0,
\end{verbatim}

同样，使用transform高阶函数，可以很方便的实现前面提出的第二个应用。例如下面仅用几行代码就实现了员工姓氏的提取：
\begin{lstlisting}[frame=single]
struct FamilyName{
	std::string operator()(std::string fullName){
		std::string::size_type idx = fullName.find(',');
		return fullName.substr(idx+2);
	}
};
List<std::string>* namelist = cons(std::string("Bill, Gates"), 
	cons(std::string("Steve, Jobs"),
	cons(std::string("Linus, Torvalds"), 
	cons(std::string("Larry, Wall"), static_cast<List<std::string>*>(0)))));
List<std::string>* familylist = transform(namelist, FamilyName());
printList(familylist);
\end{lstlisting}

程序输出：
\begin{verbatim}
Gates, Jobs, Torvalds, Wall,
\end{verbatim}


% ================================================================
%                 Lambda
% ================================================================
\section{Lambda} \label{lambda}

在第\ref{problems}节中，曾经提出过关于functor爆炸的问题。由于高阶函数操作其他函数，
因此作为作为高阶函数参数的各种普通函数会分布于程序各处。这些普通函数由用户传给高阶
函数使用，他们通常小巧简单，但却数量众多。并且高阶函数越抽象，就越能覆盖更广的应用，
也就是能够操作更多的普通函数。

这里所说的普通函数，并不一定是C++语法上的函数，而是某种程序单元，它们可以是普通函数，
更多的情况下，以functor的形式出现。随着程序越来越复杂，各种普通函数会充斥在程序的
各个角落，变得不容易维护。例如前面章节使用过的函数就有：Inc(), Inc4(), 
Self(), Cube(), MyFunc()等。

\subsection{Minor improvement}

着手解决functor数量爆炸的问题，其中一个方法仍然是利用抽象，例如Inc(), Inc4()这两个函数，
仔细观察就会发现他们有许多相似之处。可以很轻易地将其参数化为如下的一个统一的functor：
\begin{lstlisting}[frame=single]
template<class T, int n=1>
struct Increase{
	void operator()(T& x){ x+=n; }
};
\end{lstlisting}

采用这个抽象后，以前分别使用Inc()和Inc4()的地方就可以统一使用Increase()，对后继维护来说，
也从维护两个小函数，减少为维护一个小函数。如下：
\begin{lstlisting}[frame=single]
std::cout<<"sum int 1..100=" <<sumGeneric(1, 100, Self<int>(), Increase<int>())<<"\n";
std::cout<<"sum cube 1..100="<<sumGeneric(1, 100, Cube<int>(), Increase<int>())<<"\n";
std::cout<<"sum to PI 1..100="<<8.0*
		   sumGeneric(1.0, 100.0, MyFunc<double>(), Increase<double, 4>())<<"\n";
\end{lstlisting}

但是这种改进，并不能本质上解决小函数爆炸的问题。有些小函数根本无须定义，直接在需要的地方写出函数体，
甚至比命名它还要有意义（如前面的MyFunc）。

\subsection{The ultimate solution}

为了给出本质的解决方案，可以引入Lambda的概念。Lambda在最近数年中逐渐活跃并受到重视，
一些流行的语言先后加入了对Lambda演算的支持，例如python，例如C\#等等。实际上Lambda并不是什么新潮的东西，一些具有良好传统的语言如Lisp，
很早就开始大规模使用Lambda。Lambda演算\cite{lambda}由数理学家Alonzo Church在20实际30
年代引入。它对函数式编程，特别是Lisp语言有着巨大的影响。

Lambda的严格形式化定义可以参考\cite{lambda}，本文仅仅给出一个相对不严格的直观的解释\cite{sicp}。
Lambda可以表示为如下形式：

\be
(\lambda_{<formal-parameters>}. <body>)
\ee

由于计算机代码中，如发输入希腊字母，以及排版下标，所以Lambda演算可以用普通英文字母表示为\footnote{
考虑有相当数量的读者不一定懂得Lisp语言，本文没有采用Lisp的语法给出Lambda演算的例子，而采用了一种
伪代码的形式。了解Lisp语言的读者可以直接参考\cite{sicp}或者\cite{htdp}
}：

\begin{verbatim}
(lambda (<formal-parameters>). <body>)
\end{verbatim}

例如定义一个匿名函数，它接受一个自变量$x$，该函数将$x+2$，可以用lambda演算表达为：
\begin{verbatim}
(lambda (x). (x+2))
\end{verbatim}
而前面的MyFunc函数，可以直接用Lambda演算表达为：
\begin{verbatim}
(lambda (n). 1/((2*n-1)*(2*n+1)))
\end{verbatim}

有些读者难免问：“Lambda演算不过就是将函数名称变成Lambda而已么？”实际上Lambda演算的确是用来定义
函数，但是这个函数是“通过Lambda表达式匿名地定义的”，也就是函数没有名字，仅仅说明了函数会对其参数
进行什么操作。例如下面的函数调用是错误的：
\begin{verbatim}
(lambda (1))
\end{verbatim}
要想使用$x+2$这个函数，必须引入一个调用方式。假设函数$f(x)=x+2)$，普通情况下的调用方式是$f(1)$，而
使用lambda演算时要采用“左结合”的方式进行调用：
\begin{verbatim}
(lambda (x). (x+2))(1)
\end{verbatim}
事实上，甚至可以将Lambda演算的结果赋值给一个函数的名称，然后利用这个名称调用：
\begin{verbatim}
f=(lambda (x). (x+2))
f(1)
\end{verbatim}

有了Lambda演算为什么就能够解决前面叙述的小函数爆炸的问题呢？因为可以不在程序的开始部分定义众多的小函数，
而仅仅在使用高阶函数时，通过Lambda演算将匿名小函数传给高阶函数，从而实现原来的功能。例如下面的伪代码，
使用Lambda演算，实现$\pi/8$的计算：
\begin{lstlisting}[frame=single]
sumGeneric(
	1, 100, 
	lambda(n). 1/((2*n-1)*(2*n+1)),
	lambda(i). (i++)
	)
\end{lstlisting}

上述代码在使用高阶函数sumGeneric时，针对第三个参数，提供了一个匿名小函数，该函数将会针对自变量计算相邻
两个奇数乘积的倒数；针对第四个参数，也提供了一个匿名小函数，该函数将会将自变量的值增加1。

而计算$x^3$和$sin(x)$积分的例子则可以写为：
\begin{lstlisting}[frame=single]
integral(lambda(x). x*x*x, 0, pi/2, 0.001);
integral(lambda(x). sin(x), 0, 4, 0.001);
\end{lstlisting}

\subsection{How to implement?}

既然引入Lambda可以带来这样的好处，如何在C++语言中实现Lambda呢？一个自然的想法是依赖编译器，如果编译器提供
对Lambda关键字以及语法的支持，自然是“善之善者也。”但是目前没有任何C++编译器，直接支持Lambda。标准委员会审慎
而严谨的工作会仔细讨论每个提议的必要性，从而维护C++语言的完整性相容性。套用“泛函”中的一个术语，任何“非正交”
的功能都不是一个最小完备的功能集合。

那么暂时就没有办法在C++中使用Lambda演算了么？一些具有创造性的工作采用了目前C++语言的特性，
提供了一定程度的Lambda实现。比较典型的是boost库的实现\cite{boost_book},\cite{boost}。例如下面
的代码使用了boost::lambda来实现一个匿名小函数：

\begin{lstlisting}[frame=single]
#include <vector>
#include <algorithm>
#include "boost/lambda/lambda.hpp"
#include "boost/lambda/bind.hpp"

int main() {
  using namespace boost::lambda;

  std::vector<int> vec(3);
  vec[0]=12;
  vec[1]=10;
  vec[2]=7;

 // Transform using a lambda expression
  std::transform(vec.begin(),vec.end(),vec.begin(),_1-=4);
}
\end{lstlisting}

注意到其中的transform一句，其中最后一个参数应该是一个functor, 使用了boost::lambda后，这个
functor以lambda表达式\_1-=4进行定义。在这里\_1相当于普通lambda表达式中的x，其确切名称是placeholder，
其含义是目前这个函数的自变量还不清楚，但是这个函数会将自变量减去4。

也就是说，boost::lambda中，不需要用户显示地写出lambda关键字，而是使用\_1、\_2……这样的占位符来
直接描述Lambda演算中的函数体。下面是另一个简单的例子：
\begin{lstlisting}[frame=single]
#include <iostream>
#include "boost/lambda/lambda.hpp"
#include "boost/function.hpp"

int main() {
  using namespace boost::lambda;

  boost::function<void(int,int,int)> f=
    std::cout << _1 << "*" << _2 << "+" << _3
      << "=" <<_1*_2+_3 << "\n";

  f(1,2,3);
  f(3,2,1);
}
\end{lstlisting}
这个例子中，将一个lambda表达式赋值给了一个函数f，然后利用这个函数计算各种不同场合的结果。

boost库中的实现方法读者可以参考\cite{cppmeta}来了解。作者在这里给出一个独立思考出的实现，虽然
没有boost库看起来的强大。但是在语法上，实现了“前缀运算的lambda演算”。

在实现前，首先通过对几个问题的分析，寻找出思路。为此列出如下的几个问题：

\begin{enumerate}
\item 问题1：
首先面临的第一个问题是，执行如下lambda语句究竟得到了什么？

\begin{verbatim}
lambda <arg> <body>
\end{verbatim}

这个问题看似简单，但是要理解到足够程度却有一定困难。粗略回答是：“得到了一个函数”。
但是C++中函数都是通过代码静态定义的，而$<body>$部分的描述是动态的（需要通过组合，
嵌套得到的复杂表达式）。因此使用C++宏之类来实现lambda的方案就有相当的困难。

使用宏的方案虽然比较诱人，但是就地展开的一段函数代码是不能作为一个值传入高阶函数的。
这会引发C++编译错误。

所以$<body>$部分只能是一个“行为看起来像函数”的东西，也就是functor。lambda表达式中的
$<body>$是functor，而其本身又是由诸多元素组合而成（加减乘除等），由此推断，
这些元素也必然是functor。

\item 问题2：
用什么代表$<body>$中的变量？$<body>$可以是含有变量的表达式，例如\begin{verbatim}2*x+y-1\end{verbatim}
然后$<body>$这个functor可以作为一个二元函数使用，例如\begin{verbatim}<body>(1,2)\end{verbatim}

但是在functor组合过程中，显然不能使用C++的变量，因为C++的变量根本就不是一个functor。
于是得出结论：$<body>$中的变量也是functor，不过它们很特殊，它们可以将最后求值时的代换操作，
传播到$<body>$中的所有functor内。

\item  问题3：
用什么模型？最后使用\begin{verbatim}<body>(1, 2)\end{verbatim}
求值时，必须保证1传播到所有x的地方，2传播到所有y的地方，这显然是一种递归的操作。
所以模型是一种递归模型

\end{enumerate}

经过以上的分析，下面就可以开始着手进行实现，本文模仿TDD(Test Drivern Developing)的模式，
从简单到复杂一步一步解决问题。

\begin{enumerate}

\item 测试：首先来实现代表$<body>$中变量的functor，它们能够携带信息，传播进入其他functor内，
其他functor在寻找第$i$个变量时，就可以通过$var_i$的形式找到它。类似的测试代码如下：
\begin{lstlisting}[frame=single]
//test var<1>()(1, 2) = 1;
std::cout<<"var<1>()(1,2)="<<Var<1>()(1,2)<<std::endl;

//test var<2>()(1, 2) = 2;
std::cout<<"var<2>()(1,2)="<<Var<2>()(1,2)<<std::endl;
\end{lstlisting}

为此可以利用一个接受整数参数的模板来实现，如下
\footnote{这里有一个非常重要的假设：{\em
lambda表达式中的所有内容，类型都一致。}
本文暂时不处理$2.3+x*4$这样的整形、浮点型混合问题，读者可以自己思考如何解决此类问题。}：

\begin{lstlisting}[frame=single]
template<int n> struct Var;

template<> struct Var<1>{
    template<class T>
    T operator()(T a1, T a2){ return a1; }
};

template<> struct Var<2>{
    template<class T>
    T operator()(T a1, T a2){ return a2; }
};
\end{lstlisting}

实际上$Var<1>$的实例就是$<body>$中的$x$，$Var<2>$
的实例就是$y$，前者负责在众多参数中，提取出$x$，后者提取$y$。
\footnote{这里为了简单只支持2个参数。参数多到n个时的做法也可仿此实现。}

\item 测试：补充一个只有一个参数的简单情形：

\begin{lstlisting}[frame=single]
//test var<1>()(1)=1;
std::cout<<"var<1>()(1)="<<Var<1>()(1)<<std::endl;
\end{lstlisting}

这说明$<body>$是一个一元函数，实现这个功能只需要增加一个重载函数：

\begin{lstlisting}[frame=single]
template<> struct Var<1>{
    //...

    template<class T>
    T operator()(T a1){ return a1; }
};
\end{lstlisting}

\item 测试：下面前进一步，实现一个加法操作：
\begin{lstlisting}[frame=single]
std::cout<<"plus(var<1>, var<2>)(3, 4)="
<<plus(Var<1>(), Var<2>())(3, 4)<<std::endl;
\end{lstlisting}

一个自然的想法是写一个加法模板，其接受两个functor，实现如下：
\begin{lstlisting}[frame=single]
template<class Func1, class Func2>
struct Plus{
    Plus(Func1 f1, Func2 f2):_f1(f1),_f2(f2){}

    // ex: f=plus(_x, _y), f(1, 2)
    template<class T>
    T operator()(T x1, T x2){
        T x = _f1(x1, x2);
        T y = _f2(x1, x2);
        return x+y;
    }

private:
    Func1 _f1;
    Func2 _f2;
};
\end{lstlisting}

整个模板在构造时把$x$和$y$变量对应的functor保存起来。在将来调用时，
使用这两个functor分别传播x和y，然后相加即可。不过这个模板使用起来
比较不方便，例如：
\begin{lstlisting}[frame=single]
Var<1> x;
Var<2> y;
Plus<Var<1>, Var<2> > f(x, y);
f(1, 2);
\end{lstlisting}
为此可以增加一个helper函数，来方便构造加法functor，如下：
\begin{lstlisting}[frame=single]
template<class A1, class A2>
Plus<A1, A2> plus(A1 a1, A2 a2){
    return Plus<A1, A2>(a1, a2);
}
\end{lstlisting}
这样测试代码就完全可以通过了。

\item 测试：下面开发针对常量的加法，测试代码为：
\begin{lstlisting}[frame=single]
//test plus(1,2)() = 3;
std::cout<<"plus(1, 2)()="<<plus(1, 2)()<<std::endl;
\end{lstlisting}
由于最后的$<body>$ functor，不接受任何参数。所以可以通过为Plus模板增加
一个重载函数实现，如下：
\begin{lstlisting}[frame=single]
template<class Func1, class Func2>
struct Plus{
    Plus(Func1 f1, Func2 f2):_f1(f1),_f2(f2){}

    //...

    // ex: f=plus(1, 2), f()
    //means that _f1 & f2 are premiers
    Func1 operator()(){
        return _f1+_f2;
    }

private:
    Func1 _f1;
    Func2 _f2;
};
\end{lstlisting}

\item 测试：这次增加一些难度，加入一个变量。
\begin{lstlisting}[frame=single]
//test plus(var<1>, 3)(2) = 2+3 = 5;
std::cout<<"plus<var<1>, 3)(2)="
    <<plus(Var<1>(), 3)(2)<<std::endl;
\end{lstlisting}
正如注释所说明的，\_f1或者\_f2之一是一个基本类型。当然也不排除他们
都是一元functor的可能。直观的做法是再增加一个只接受一个参数的重载
版本。但是究竟\_f1是基本类型呢，还是\_f2是基本类型呢？如果\_f1是基本
类型，最终结果应该是：
\begin{verbatim}
_f1+_f2(x)
\end{verbatim}
反之就是：
\begin{verbatim}
_f2(x)+_f1
\end{verbatim}
如果他们都是一元函数，则结果是：
\begin{verbatim}
_f1(x)+_f2(x)
\end{verbatim}
但是C++的特性决定了，不能写出这样的语句：
\begin{lstlisting}[frame=single]
int a;
int b;
if(_f1 is preimers)
  a= _f1;
else
  a= _f1(x);

if(_f2 is preimers)
  b= _f2;
else
  b= _f2(x);

return a+b;
\end{lstlisting}

这是因为，如果\_f1真的是基本类型，则else一句在编译时会出现语法错误。
所以解决方案是，使用模板偏特化。

首先，利用Andrie的方法，构造基本类型列表\cite{moderncpp}：
\begin{lstlisting}[frame=single]
template<class T, class U>
struct TList{
    typedef T First;
    typedef U Rest;
};

typedef TList<int, 
    TList<long, 
        TList<char, 
            TList<float ..., Empty> > ... > Premiers;
\end{lstlisting}
然后编写一个编译期程序，用于判断某个类型是否是基本类型：
\begin{lstlisting}[frame=single]
template<class TypeList, class T> struct Find{
    static const int value = 1 + Find<typename TypeList::Rest, T>::value;
};

template<class T, class U> struct Find<TList<T, U>, T>{
    static const int value = 0;
};

template<class T> struct Find<Empty, T>{
    static const int value = -1000;
};

template<class Func> struct IsFunctor{
    static const bool value = Find<Premiers, Func>::value < 0;
};
\end{lstlisting}

其中Find程序利用递归的方法在类型列表中寻找某类型是否是存在，如果找到，
则返回一个非负整数（类型在列表中的下标），反之返回一个负数。

然后IsFunctor程序利用这个特点，判断某个类型是一个基本类型还是Functor。

此后就可以利用这两个程序，建立偏特化模板，处理一元Plus函数，偏特化的模板
名叫Eval,实现如下：
\begin{lstlisting}[frame=single]
template<bool isFunctor> struct Eval;

// f is a functor
template<> struct Eval<true>{
    template<class F, class T>
    static T apply(F f, T x){
        return f(x);
    }

    template<class F, class T>
    static T apply(F f, T x1, T x2){
        return f(x1, x2);
    }
};

// f is not a functor
//  ==>f is const premier value;
template<> struct Eval<false>{
    template<class F, class T>
    static T apply(F f, T x){
        return f;
    }
};
\end{lstlisting}
这个模板使用apply来将一个函数作用到其自变量上。对于基本类型的情况，
则直接返回基本类型的值。使用Eval后，原来的Plus模板改写如下：
\begin{lstlisting}[frame=single]
template<class Func1, class Func2>
struct Plus{
    Plus(Func1 f1, Func2 f2):_f1(f1),_f2(f2){}

    // ex: f=plus(_x, _y), f(1, 2)
    template<class T>
    T operator()(T x1, T x2){
        T x = IsFunctor<Func1>::value ? _f1(x1, x2) : x1;
        T y = IsFunctor<Func2>::value ? _f2(x1, x2) : x2;
        return x+y;
    }

    // ex: f=plus(_x, 1), f(2)
    template<class T>
    T operator()(T x1){
        T x = Eval<IsFunctor<Func1>::value>::apply(_f1, x1);
        T y = Eval<IsFunctor<Func2>::value>::apply(_f2, x1);
        return x+y;
    }

    // ex: f=plus(1, 2), f()
    //means that _f1 & f2 are premiers
    Func1 operator()(){
        return _f1+_f2;
    }

private:
    Func1 _f1;
    Func2 _f2;
};
\end{lstlisting}

\item 测试：下面基本是验证性测试了。试试复合表达式：
\begin{lstlisting}[frame=single]
//test plus(var<1>, plus(var<1>, 2)(1)= 1 + 1 + 2 = 4;
	std::cout<<"plus(var<1>, plus(var<1>, 2)(1)="
		<<plus(Var<1>(), plus(Var<1>(), 2))(1)<<std::endl;
\end{lstlisting}

程序已经不需要做任何改动和添加，就可以完成这个测试。

\end{enumerate}

前面的所有测试运行结果如下：
\begin{verbatim}
var<1>()(1,2)=1
var<2>()(1,2)=2
var<1>()(1)=1
plus(1, 2)()=3
plus(var<1>, var<2>)(3, 4)=7
plus<var<1>, 3)(2)=5
plus(var<1>, plus(var<1>, 2)(1)=4
\end{verbatim}

至此，plus就完成了。仿照plus，可以写出minus, times, divide等二元函数，
它们非常相似，所以可以采用Policy的方式，将运算符Op注入\cite{moderncpp}。
同理可以实现一元函数。这样就可以利用这些函数组合出Lambda表达式。

最终的lambda，不过是前面内容的语法糖衣，以方便读者理解和使用：

\begin{lstlisting}[frame=single]
#define _x Var<1>()
#define _y Var<2>()

struct Empty;

template<class A1, class A2>
int arg(A1 a1, A2 a2){ return 0; }

template<class A1>
int arg(A1 a1){ return 0; }

template<class T>
T body(T f){ return f; }

template<class T>
T lambda(int /*arg*/, T f){ return f;}
\end{lstlisting}

这个lambda的使用方式，更像lisp语言――它使用前缀运算表达式。而不是C++
语言的中缀运算表达式。例如：
\begin{verbatim}
(* 2 (+ x 1))
\end{verbatim}
而不是
\begin{verbatim}
2*(x+1)
\end{verbatim}
如果希望使用中缀表达式，可以通过重载全局operator+(), operator*()来实现。
读者可以自行尝试。
下面是一个使用本文给出的lambda演算，调用高阶函数的例子：
\begin{lstlisting}[frame=single]
template<class F>
int sum(int a, int b, F f){
  int res(0);
  for(int i=a; i<b; ++i)
    res+=f(i);
  return res;
}

int main(int argc, char** argv){
  std::cout<<"[f(x)=2*(x+1)], f(1)+f(2)+...+f(100)="
    <<sum(1, 100, lambda(arg(_x), body(times(2, plus(_x, 1)))))<<"\n";
}
\end{lstlisting}
程序输出：
\begin{verbatim}
[f(x)=2*(x+1)], f(1)+f(2)+...+f(100)=10098
\end{verbatim}

% ================================================================
%                 Summary
% ================================================================
\section{Summary}
至此，本文从意义重复的程序出发，抽象出了高阶函数；进一步又从解决functor数量众多、难以
维护的问题前进，引出了lambda的概念，并独立给出了一个lambda的实现。这与其他lambda的实现，
例如\cite{lambda_cpp_more}相比，虽然在lambda的体部分，功能受限。但是由于其具有“值”的特性，因此直接作为一个部分嵌入
表达式。

在本文的下半部分，作者还将继续深入探讨相等的问题，并进一步引出“邱奇”数和Y组合子的概念。
由于作者水平有限，本文中错误想必比比皆是，还望读者批评指正。

\begin{thebibliography}{99}

\bibitem{sicp}
Harold Abelson and Gerald Jay Sussman with Julie Sussman. ``Structure and Interpretation of Computer Programs." second edition. The MIT Press.

\bibitem{moderncpp}
Andrei Alexandrescu, ``Modern C++ Design: Generic Programming and Design Pattern Applied." Addison Wesley, Feb. 2001

\bibitem{scheme_cpp}
Liu Xinyu, ``Scheme and C++ template." 2006, June. \\ http://baredog.at.infoseek.co.jp/intl/chn/softdev/book1/essay7.htm

\bibitem{lambda}
Wikipedia, ``Lambda calculus." 2006, June. \\ http://en.wikipedia.org/wiki/Lambda\_calculus

\bibitem{htdp}
Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, Shriram Krishnamurthi. ``How to Design Programs, An Introduction to Computing and Programming." The MIT Press, 2001

\bibitem{boost_book}
Bj\"{o}rn Karlsson. ``Beyond the C++ Standard Library: An Introduction to Boost." Addison Wesley Professional, August 31, 2005 

\bibitem{boost}
Boost C++ Libraries. http://www.boost.org/

\bibitem{cppmeta}
David Abrahams, Aleksey Gurtovoy. ``C++ Template Metaprogramming: Concepts, Tools, and Techniques from Boost and Beyond." Addison Wesley Professional, December 10, 2004.

\bibitem{lambda_cpp_more}
``Lambda abstractions in C++ vs. Scheme." http://okmij.org/ftp/c++-digest/Lambda-CPP-more.html

\end{thebibliography}

\ifx\wholebook\relax\else
\end{document}
\fi
