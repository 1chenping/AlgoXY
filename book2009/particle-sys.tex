\ifx\wholebook\relax \else
% ------------------------ 

\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
\input{common.tex}

\setcounter{page}{1}

\begin{document}

\fi
%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Simulate epidemic by programming\\
通过编程模拟疾病的传染}

\author{刘新宇(Liu~Xinyu)
\thanks{{\bfseries Liu Xinyu } \newline
  Email: liuxinyu95@gmail.com \newline
  Tel:   +86-1305-196-8666 \newline}
  }

\markboth{Simulate epidemic by programming}
{Simulate epidemic by programming}

\maketitle

\ifx\wholebook\relax
\chapter{Simulate epidemic by programming}

\section{abstruct}
\else
\begin{abstract}
\fi

计算机对于复杂大系统的模拟很有帮助，这种模拟，或者叫仿真，不仅仅可以帮助我们
快速了解自然科学中的一些系统，例如复杂的粒子运动系统；还往往能够在一定程度上
能支持我们研究社会科学中的系统。本文通过编程来给出一个疾病传染的仿真示例，希望
能够给读者以启示。也算是对当前甲型H1N1流感的防治尽一些绵薄之力。

由于作者水平有限，文中难免有谬误之处，欢迎广大读者指正！
本文使用\LaTeXe排版，遵循FDL(GNU Free Documentation License)许可协议。
并受其保护。具体请参考：http://www.gnu.org/copyleft/fdl.html

\ifx\wholebook\relax\else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Epidemic simulation, Squeak, C++

{\bfseries Corresponding Author:} 刘新宇

\maketitle

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

%\begin{verse}
%子曰：学而不思则罔，死而不学则殆。%\\
%\end{verse}
%\begin{flushright}
%――《论语》
%\end{flushright}

%\begin{figure}[htbp]
%       \begin{center}
%	\includegraphics[scale=0.5]{images/peace.eps}
%        \caption{from www.zikai.org}
%       \end{center}
%\end{figure}

去年地震灾害的时候，我就常常问自己：“抗震救灾，一个普通的程序员能够做些什么？”。Google很快
给出了灾区的地图，各大网站及时报道救灾的新闻。可是对于普通程序员来说，如何才能发挥所长，尽
一份贡献呢？当前，正值甲型H1N1流感在世界蔓延，这个问题再次引起我的思考。

希望能通过这篇文章，尽我自己的一点绵薄之力。我将依次通过计算机程序给出一些直观的仿真结果，包括下面的几种情形：
\begin{itemize}
\item 传染病发生时，如果不采取任何防治措施的传播速度
\item 具有一定传播概率时的传播速度；
\item 公众自发防防治，主动采取隔离措施，及时治疗时的传播速度；
\item 带有一定潜伏期时的传播速度。
\end{itemize}

\section{method 1}
\label{method1}

\subsection{Kedama, a simple epidemic simulation example}

著名的Smalltalk程序员大岛芳树(Ohshima Yoshiki)曾经为squeak开发了一个叫做Kedama的项目。这个项目现在已经是
OLPC(one laptop per child)中Etoy的一部分。它可以非常直观的模拟疾病的流行\cite{kedama}, 西邮Linux兴趣小组
的同学们曾经帮助翻译了中文的介绍文章。下图是Kedama运行过程中的一幅截图：

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{images/kedama.eps}
        \caption{screen shot of kedama}
       \end{center}
\end{figure}

图中，黑色的方块表示一个封闭的区域。区域中一共有1000个点表示在其中自由运动的人，红色的点表示已经感染某种疾病的个体，
而绿色的点表示健康的个体。健康的个体如果接触到染病的个体就会被传染。Kedama的设计非常直观，其运行结果也非常惊人。
在完全自由运动的情况下，疾病在非常短的时间内感染了所有的人。

虽然Squeak和Etoy被设计为针对8到11岁的儿童学习使用，但是考虑到国内了解Smalltalk的人并不多。作者下面用C++来实现
一个类似的模拟。

首先是建模问题。其中一种建模的方法是采用简单的“暴力”解法，如果需要模拟一种疾病在1000个人中的传播，就开启1000个独立的
线程，每个线程代表一个人，并行在某区域内随机运动。其中一个线程被设置为已染病个体。每个线程在随机运动过程中，都检查和
自己遇到的其他人，是否已经染病。和染病线程接触后，自己就变成另一个染病线程。

这个方法，虽然看起来直观，然而却有两个问题难以解决。第一个问题是性能问题。虽然在现代的多核计算机上，同时开启多个线程
的性能已经大大提高，但是如果模拟人群的规模增大，例如模拟大型城市如北京、上海的上千万的人口，同时开启几千万的线程，这样
的计算，恐怕要使用超级计算机了。第二个问题是一个算法问题，也就是每个线程代表的人在独立运动中，如何判断自己和其他线程
代表的人接触到了？是否要在全体线程中做一个查找？如果是这样，完成某个人走一步，然后进行查找的算法为线性算法，其复杂度为$O(n)$，
n个线程的计算量为$O(n^2)$。这是非常大的计算量，算法的效率会非常低。

根据Kedama的启发，在做出一定的化简后，可以找到一个简单、高效的方法。假设需要在$W \times H$平方米的范围内，模拟
某种疾病在N个人中的传播。我们可以将区域划分为$W \times H$个格子，也就是每平方米一个格子。然后我们建立N个对象，放入
一个列表。每次模拟遍历一遍这个列表，让每个人独立走一步；同时，我们检查这个人是否染病，如果染病，我们就标记他所在的
那个格子（也就是那一位置所在的1平方米）为污染区。之后我们重新遍历这个列表一次，检查每个人所在的区域是否为污染区，如
果一个健康对象经过运动后进入了污染区，他就被标记为感染。我们的模拟程序不断重复上述的两步过程：移动――感染，直到90\%
的人染病后，程序退出。

下面我们来一步一步实现上述程序。首先是区域的建模，这部分非常简单。类定义如下：
\begin{lstlisting}
class area{
public:
  area(int w, int h):_width(w), _height(h){
    cells=new char[w*h];
    reset();
  }
  virtual ~area(){ delete cells; }

  int width(){ return _width; }
  int height() { return _height; }

  char* at(int x, int y){
    return cells+y*_width+x;
  }

  void reset(){ memset(cells, 0, _width*_height); }

private:
  int _width;
  int _height;
  char* cells;
};
\end{lstlisting}

其中cells是一个buffer，其实代表的是w列、h行的二维格子，我们将用它来标记污染区。之所以
采用原始的buffer，是出于效率考虑。我们可以通过memset和随机访问操作。快速地重置污染区
和访问污染区。

之后需要对人进行建模，对于在疾病传播模拟程序中的人，我们只关心两个方面：1，他是否染病？2，他
目前在哪里，向那个方向以多快速度进行运动？对于1，我们可以以一个bool量来代表；对于2，我们
需要对位置和运动信息建模。这一模型如下:

\begin{lstlisting}
struct physics{
  physics(){}
  physics(int _x, int _y, int _s, int _d):x(_x), y(_y), 
      speed(_s), direction(_d){}
  physics(const physics& p):x(p.x), y(p.y), 
      speed(p.speed), direction(p.direction){}
  physics& operator=(const physics& p){
    x=p.x; y=p.y;
    speed=p.speed; direction = p.direction;
  }

  bool operator==(const physics& p){
    return x==p.x && y==p.y && speed== p.speed && 
           direction == p.direction;
  }

  void move(double dt){
    x+=static_cast<int>(static_cast<double>(speed)*dt*
             cos(static_cast<double>(direction)/180.0*pi));
    y+=static_cast<int>(static_cast<double>(speed)*dt*
             sin(static_cast<double>(direction)/180.0*pi));
    speed = rand() % MAX_SPEED;
  }

  int x;
  int y;
  int speed;
  int direction;
};
\end{lstlisting}

物理量包括位置坐标x,y，以及运动的速率speed和运动的方向direction（本程序中使用角度）。定义拷贝构造函数，复制以及相等
是为了方面操作。其中值得注意的是运动函数move，它接受一个运动时间小量dt，然后在二维平面上以当前的运动速度和方向更新位置，
最后再更新运动速率。考虑到人在步行时的运动速率为3km/h，我们的最大速率设置为50m/min。

有了物理运动信息，接下来就可以定义被模拟的人了：

\begin{lstlisting}
class person{
public:
  person(bool x=false):_infected(x){}
  person(const person& p):_infected(p._infected), _loc(p._loc){}
  person& operator=(const person& p){
    _infected = p._infected;
    _loc = p._loc;
    return *this;
  }

  physics location() const{ return _loc; }
  void set_location(const physics& l){ _loc=l; }
  bool infected() const { return _infected; }
  void set_infected(bool x) { _infected = x; }

  void move_inside(area& a, double dt){
    _loc.move(dt);
    if(_loc.x<0 || _loc.x>a.width())
      _loc.direction = (180 - _loc.direction + 360) % 360;
    if(_loc.y<0 || _loc.y>a.height())
      _loc.direction = (-_loc.direction + 360) % 360;
    if(_loc.x<0)
      _loc.x=-_loc.x;
    if(_loc.x>a.width())
      _loc.x=2*a.width()-_loc.x;
    if(_loc.y<0)
      _loc.y=-_loc.y;
    if(_loc.y>a.height())
      _loc.y=2*a.height()-_loc.y;
  }

private:
  bool _infected;
  physics _loc;
};
\end{lstlisting}

这段定义中，除了构造、拷贝、赋值以及getter/setter之外，只有一个move\_inside函数，
它是模拟人在某区域运动的关键函数。该函数接受一个区域引用和一个时间小量。然后调用前面
定义的move函数更新物理信息。如果发现人已经运动出所限制的区域。程序按照物理上弹性碰撞
的规律，将人限制回区域内，并让他的运动根据弹性反向。读者也可以不采用弹性碰撞，而使用
其他物理模型。

模拟程序的核心，是一个被称为scheduler的类。之所以起这个名字，是因为它的运行上，本质
类似于一个调度器――一次取出列表中的每个人，然后让其运行\cite{ao}。首先它被设计为一个
sigleton：
\begin{lstlisting}
class scheduler{
public:
  static scheduler& inst(){
    static scheduler _inst;
    return _inst;
  }
  //...

private:
  scheduler(){}
  ~scheduler(){ 
    delete a; 
    for(Population::iterator it=people.begin(); it!=people.end(); ++it)
      delete *it;
  }

  area* a;
  typedef std::list<person*> Population;
  Population people;
  int n_infected;
  std::list<int> diagram;
};
\end{lstlisting}

scheduler拥有一个指向模拟区域的指针a，一个记录全体被模拟人口的列表people。一个记录已染病人数
的变量n\_infected，和一个用于将模拟结果写入文件的列表diagram。scheduler在最后析构时会释放
所有被模拟人的对象。这里之所以没有采用person对象的列表，而采用了person指针的列表。是因为在语义
上，我们并不关心不同个体的差异。我们并不能说，在同一位置，以同一速度运动的不同对象是相等的，因为
他们完全可以是不同的人。

scheduler在初始化时，设置好区域，创建出n-1个健康个体和一个染病个体。然后把它们随机放入区域中
的各种位置。并设置目前的染病人口数为1。

\begin{lstlisting}
class scheduler{
  //...

  void setup(int w, int h, int n){
    a=new area(w, h);
    for(int i=0; i<n-1; ++i)
      people.push_back(new person());
    people.push_back(new person(INFECTED));
    put_people(people, *a);
    n_infected = 1;
  }

  //...
private:
  template<class Coll>
  void put_people(Coll& coll, area& a){
    for(typename Coll::iterator it=coll.begin(); it!=coll.end(); ++it){
      (*it)->set_location(physics(rand()%a.width(), rand()%a.height(),
                                  rand()%MAX_SPEED, rand()%360));
    }
  }
\end{lstlisting}

scheduler的核心函数是run()，它按照我们最初设计的算法，每次遍历全部人口，执行移动――感染两个步骤，
为了直观，函数还在每次模拟后，显示输出当前时间（单位是分钟），在总人口中有多少人已染病。并在diagram
列表中，记录染病人数随时间变化的曲线。当90\%的人口染病后，程序退出。

\begin{lstlisting}
class scheduler{
  //...

  void run(){
    for(int tm=0; n_infected < people.size()*90/100; tm++){
      a->reset();
      move();
      infect();
      std::cout<<"time "<<tm/60<<":"<<tm%60<<" "
               <<n_infected<<"/"<<people.size()<<" are infected\r";
      diagram.push_back(n_infected);
    }
    write_diagram();
  }
\end{lstlisting}

移动――感染的两个函数分别由move()和infect()实现。移动步骤遍历全部人口，针对每个人，调用move\_insdie()
函数；如果当前个体已被感染，则标记他所在的位置为污染区（设置为1）。然后在感染步骤中，程序再次遍历全部人口，
针对每个健康人，如果他所在的区域已经污染，则将此人标记为患病；并增加染病人口数量。

\begin{lstlisting}
class scheduler{
  //...
private:
  void move(){
    for(Population::iterator it=people.begin(); it!=people.end(); ++it){
      (*it)->move_inside(*a, dt);
      if((*it)->infected())
        *(a->at((*it)->location().x, (*it)->location().y))=1;
    }
  }

  void infect(){
    for(Population::iterator it=people.begin(); it!=people.end(); ++it)
      if(*(a->at((*it)->location().x, (*it)->location().y))){
        n_infected += (*it)->infected()?0:1;
        (*it)->set_infected(true);
      }
  }

  void write_diagram(){
    std::ofstream file("diagram.csv");
    std::copy(diagram.begin(), diagram.end(), 
       std::ostream_iterator<int>(file, "\n"));
  }
};
\end{lstlisting}

我们注意到，这个算法在每一步的运算复杂度为$O(n)$，而非$O(n^2)$。程序最后使用STL的copy算法和insert iterator
将染病人口随速度变化的曲线写入一个csv文件，供我们使用Excel进行后继分析。

程序的主函数main非常简单：
\begin{lstlisting}
int main(int argc, char** argv){
  //Beijing has people density as 888 persons/km^2, 
  //==> 1061 m^2 is the best fit
  scheduler::inst().setup(1061, 1061, 1000);
  scheduler::inst().run();
}
\end{lstlisting}

为了接近真实情况，考虑到北京市的人口密度为888人/平方公里，如果样本人群为1000，在1061米长1061米宽的区域内模拟
即可。程序最后输出：

\begin{verbatim}
time 124:34 900/1000 are infected
\end{verbatim}

结果非常惊人！虽然只有一个人染病，但是仅仅过了124小时后，就有9成的人群被感染。如果考虑到人群旨在白天活动8小时，则
在不进行任何防护措施的情况下，接触即传染的疾病仅仅需要2周，就可以使城市中的9成人口感染。这就是为什么在古代，瘟疫可以
迅速消灭一个城市。

我们用Excel将染病曲线绘制出来，如下：

\begin{figure}[htbp]
       \begin{center}
	\includegraphics[scale=0.5]{images/epidemic-free.eps}
        \caption{infected people along time}
       \end{center}
\end{figure}

这是一个标准的指数曲线。也就是说，在无任何防控措施的情况下，传染病会以指数速度进行传播。

% ================================================================
% epidemic with possibility factor
% ================================================================
\section{epidemic with possibility factor}
\label{p-factor}

前一方法的缺点就是效率很低。如果可能的英文串长度为n，则全排列算法本身的计算量为n!，
hasPattern的算法复杂度为$O(n^2)$。为了提高效率，需要找到更好的算法。

仍然从题目本身出发，存在一个比较直观的思路。根据一个AB串，生成全部合法的英文串可以这样考虑：
假设已经根据长度为n的AB串中的后n-1个AB子串，生成了全部英文串(包含b,c,...到第n+1个英文字母），现在要根据第1个AB，生成最终结
果。
如果第一字符是A，那么只要试图把a插入到现有结果中b的前面，就获得了全部方案；
如果第一字符是B，那么只要试图把a插入到现有结果中b的后面，就获得了全部方案；
如果现有结果是空，那么只有一个方案，就是a。

根据这一思路用Haskell实现的代码如下(C++的实现思路和代码在后面给出)：
\begin{lstlisting}
enumStrR from [] = [[from]]

enumStrR from ('A':ps) = foldl (++) [] (map f (enumStrR (from+1) ps)) where
    f = insert_before from
    insert_before y (x:xs) = if x==y+1 
        then [y:x:xs]
        else [y:x:xs]++ (map (x:) (insert_before y xs))

enumStrR from ('B':ps) = foldl (++) [] (map f (enumStrR (from+1) ps)) where
    f = insert_after from
    insert_after y (x:xs) = if x==y+1 
        then map (x:) (insert_any y xs)
        else map (x:) (insert_after y xs) where 
            insert_any y [] = [[y]]
            insert_any y (x:xs) = [y:x:xs]++(map (x:) (insert_any y xs))

enumStr2 = enumStrR 1
\end{lstlisting}

下面对这段代码给出一些解释。首先看最后一句，enumStr2 = enumStrR 1，这句比较简单。意思就是枚举具备pattern（例如pattern为"AAABBA"）形式的
所有英文串，可以这样调用：
enumStr2 "AAABBA"，实际上，就是“递归从1（也就是字母a）枚举所有英文串的意思”，相当于enumStrR 1
"AAABBA"。

如果pattern是空，那么结果就是[[from]]，也就是[[1]]
如果pattern不空，则取出第一字母，根据他是A或者B分别处理。
enumStrR (from+1) ps，是从a的后继字母(也就是from+1)b开始，根据除第一字母外剩余字母枚举所有的方案。
对这些方案集合中的每个元素应用（也就是map）insert\_after或者insert\_before，如果是A就调用insert\_before，否
则调用insert\_after。
这样就会针对每个元素生成若干方案，把他们加到一起（利用foldl，初始值空集合和序列相加运算++），就是最终结果。

insert\_before实现很简单：
\begin{lstlisting}
insert_before y (x:xs) = if x==y+1 
    then [y:x:xs]
    else [y:x:xs]++ (map (x:) (insert_before y xs))
\end{lstlisting}
他的含义就是，如果待插入序列的首字符就是待插入字符的后继字符，（例如待插入字符为a，待插入序列为bcd的形式）。那么就仅有一种方案。（对应为
abcd），否则，就把这一方案（abcd)，和递归地把该字符向除去首字符的子串中insert\_before的结果合并为最终结果。

insert\_after稍微复杂一些：
\begin{lstlisting}
insert_after y (x:xs) = if x==y+1 
    then map (x:) (insert_any y xs)
    else map (x:) (insert_after y xs) where
        insert_any y [] = [[y]]
        insert_any y (x:xs) = [y:x:xs]++(map (x:) (insert_any y xs))
\end{lstlisting}
针对首字符为待插入字符后继字符的情况，我们可以把待插入字符通过insert\_any插入到任意位置，反之。就要递归地寻找后继字符，并完成插
入。insert\_any的实现极为简单，这里不再赘述。

枚举所有方案后，获得方案数目就非常简单了：
count2 = length.enumStr2

现在，就可以检验这一方法的正确性，可以通过和方法1的结果对比：
\begin{verbatim}
EnumStr> enumStr2 "AAABBA"
[[1,2,3,6,5,4,7],[1,2,6,3,5,4,7],[1,6,2,3,5,4,7],[6,1,2,3,5,4,7],
[1,2,6,5,3,4,7],[1,6,2,5,3,4,7],[6,1,2,5,3,4,7],[1,6,5,2,3,4,7],
[6,1,5,2,3,4,7],[6,5,1,2,3,4,7],[1,2,3,6,5,7,4],[1,2,6,3,5,7,4],
[1,6,2,3,5,7,4],[6,1,2,3,5,7,4],[1,2,6,5,3,7,4],[1,6,2,5,3,7,4],
[6,1,2,5,3,7,4],[1,6,5,2,3,7,4],[6,1,5,2,3,7,4],[6,5,1,2,3,7,4],
[1,2,6,5,7,3,4],[1,6,2,5,7,3,4],[6,1,2,5,7,3,4],[1,6,5,2,7,3,4],
[6,1,5,2,7,3,4],[6,5,1,2,7,3,4],[1,6,5,7,2,3,4],[6,1,5,7,2,3,4],
[6,5,1,7,2,3,4],[6,5,7,1,2,3,4],[1,2,3,6,7,5,4],[1,2,6,3,7,5,4],
[1,6,2,3,7,5,4],[6,1,2,3,7,5,4],[1,2,6,7,3,5,4],[1,6,2,7,3,5,4],
[6,1,2,7,3,5,4],[1,6,7,2,3,5,4],[6,1,7,2,3,5,4],[6,7,1,2,3,5,4],
[1,2,6,7,5,3,4],[1,6,2,7,5,3,4],[6,1,2,7,5,3,4],[1,6,7,2,5,3,4],
[6,1,7,2,5,3,4],[6,7,1,2,5,3,4],[1,6,7,5,2,3,4],[6,1,7,5,2,3,4],
[6,7,1,5,2,3,4],[6,7,5,1,2,3,4]]
EnumStr> count2 "AAABBA"
50
EnumStr> count1 "AAB" == count2 "AAB"
True
EnumStr> count1 "AABB" == count2 "AABB"
True
EnumStr> count1 "AABBB" == count2 "AABBB"
True
EnumStr> count1 "A" == count2 "A"
True
EnumStr> count1 "AA" == count2 "AA"
True
EnumStr> count1 "ABA" == count2 "ABA"
True
\end{verbatim}

以上Haskell的实现，基本是采用函数式的递归实现。如果使用C++，则可以根据题目的
定义使用命令式的方式。下面是C++的程序代码。

\begin{lstlisting}
typedef list<string> ResultList;

ResultList insertChar(string inst, char c){
  ResultList res;
  typedef string::size_type size_type;
  size_type pos=inst.find(*max_element(inst.begin(), inst.end()));
  size_type from= (c=='A')? pos+1 : 0;
  size_type to  = (c=='A')? inst.length() : pos;

  for(size_type i=from; i<=to; ++i){
    string s(inst);
    s.insert(i, 1, char(inst[pos]+1));
    res.push_back(s);
  }
  return res;
}

ResultList enumStr2(string pattern){
  ResultList res;
  res.push_back(string("a"));
  for(string::iterator it=pattern.begin(); it!=pattern.end(); ++it){
    ResultList new_res;
    for(list<string>::iterator inst=res.begin(); inst!=res.end(); ++inst){
      ResultList s=insertChar(*inst, *it);
      copy(s.begin(), s.end(), 
           insert_iterator<ResultList>(new_res, new_res.end()));
    }
    res=new_res;
  }
  return res;
}
\end{lstlisting}

这断代码中，enumStr2是主程序，维护一个结果列表res，该列表被初始化为含有一个英文字符串"a"，程序依次从AB串
中取出下一个字符，并且遍历结果列表，根据字符是A或者B来将下一个英文字符插入当前结果中。由于插入的方案有多个，所以
insertChar返回的是一集中间结果。主程序接着调用标准库的copy算法，把这一集结果添加到新的结果列表new\_res中。
最后使用新结果列表替换老的列表，然后继续遍历AB串直到结束。

insertChar子程序负责根据A或者B生成一集插入方案。它首先找出当前英文串中的最大字母的位置。如果要插入的位置
是该字母后方，就依次生成从该位置其到字符串最后一个字符后面插入下一字符的所有方案；如果要插入的位置是该字母的前方，
就依次生成从字符串起始位置到该位置前插入下一字符的所有方案。

这段程序的调用方法如下。

\begin{lstlisting}
int main(int, char**){
  ResultList res=enumStr2("AAABBA");
  for_each(res.begin(), res.end(), Print());
  cout<<"total solution:"<<res.size()<<"\n";
}
\end{lstlisting}

程序输出：
\begin{verbatim}
f g e a b c d 
f e g a b c d 
f e a g b c d 
...
a b c f e d g 
total solution:50
\end{verbatim}

% ================================================================
%                 method 3
% ================================================================
\section{Method 3} \label{method3}

采用第二种方法候，算法的复杂度得到了一定的降低。如果AB串的长度为n，大致最坏情况估计为:
$1!+2!+3!+...+n!$。并且题目本身并没有要求列出所有的串，只需要得出符合要求串的个数就可以了。

为了进一步寻找更好的思路。首先我们考虑平凡情况，如果AB串的内容都是A，则只有一个解答
就是abc...；如果AB串的内容都是B，则也只有一个解答，就是...cba。

现在考虑一个例子AAB。如前面分析的AA已经决定了abc的先后顺序，现在B字母决定了d必然在c的前面。
所以d可以放置的位置如下:
\begin{verbatim}
(1) a (2) b (3) c
\end{verbatim}
也就是d可以放在1,2,3任何一个位置。因此我们对于形如AAA...AB(n个A)的串（对BBB...BA亦然）的个数可以确定为n+1

下面考虑AABB，增加了一个B后，我们需要在d的前面放置e，我们依次展开放置d时的3种分支

(1): 对于把d放置在这个位置，只有一个选择，把e放置在d的前面；
(2): 对于把d放置在这个位置，有2个选择：(1) a (2) d b c；
(3): 对于吧d放置在这个位置，有3个选择：(1) a (2) b (3) d c；

规律是，当把前一个字母放在第i个位置时，我们有$C_i^1=i$个子方案，写成树状结构如下：

\begin{verbatim}
       3
 1,    2,    3
\end{verbatim}

进一步考虑串AABBB，依照上述分析，总方案树如下：
\begin{verbatim}
        3
 1,     2,     3
 1,   1, 2   1,2,3
\end{verbatim}

对应AABBBB的方案树为：
\begin{verbatim}
            3
1,      2,               3
1,   1,    2,     1,    2,     3
1,   1,  1, 2    1,  1, 2  1,2,3
\end{verbatim}

每次把叶子节点的值加起来就是最终结果。

现在考虑AAABBA，根据上面的分析，可以很容易写出前面3个A和2个B的树形方案：
\begin{verbatim}
       4
1  2   3   4
\end{verbatim}
但是根据第5个A, 字母g要放在f的后面。而放置字母f的方案总数为$C_1^1+C_2^1+C_3^1+C_4^1=1+2+3+4$分别对应放在(1)最左, (2)最左或左数第2，(3)最左或左数第2或第
3....等子方案。

所以对应f放在最左，有$C_{3+2+1}^1=6$种放置g的方案，分别放在左数第2到第7;

对应f放在左数第2，有5种放置g的方案，分别对应放在左数第3到第7

...

因此AAABBA的方案树为：
\begin{verbatim}
                4
1      2       3          4
6    6 5     6 5 4     6 5 4 3
\end{verbatim}

现在考虑AAABBAA，我们可以用前面同样的思路，给出方案数为：

\begin{verbatim}
                     4
1           2                 3                      4
6       6      5        6    5     4      6      5     4   3
1..6  1..6    1..5    1..6 1..5  1..4    1..6  1..5  1..4 1..3
\end{verbatim}

通过上述分析，最终的规律可以归纳为：
对于形如AA...(n1个)...A BB...(n2个)...B AA...(n3个)...A ... BB...(np个)...B的AB串，我们只要把方案树画出来，然后计算最后一行的数
字和就可以了。
数根的值为n1+1，然后第1层为1到n1+1，然后从该层每个值为i的节点，分支出1...i的子树，重复下去，直到n2层
然后第n3层从每个值为i的节点，分支出(n1+n2+n3)-i+2..(n1+n2+n3+1)的子树。 

根据这一方法可以很方便的给出计算程序。首先介绍c++程序

\begin{lstlisting}
template<typename Coll>
void insertRange(int from, int to, Coll& res){
  int step = from<to ? 1 : -1;
  for(;;from+=step){
    res.push_back(from);
    if(from==to)
      break;
  }
}

int enumStr3(string pattern){
  list<int> res(1,1);
  for(int i=0; i<pattern.length(); ++i){
    list<int> new_res;
    if(i && pattern[i]!=pattern[i-1])
      for(list<int>::iterator node=res.begin(); node!=res.end(); ++node)
        insertRange(i+1, i-*node+2, new_res);
    else
      for(list<int>::iterator node=res.begin(); node!=res.end(); ++node)
        insertRange(1, *node, new_res);
    res=new_res;    
  }
  return accumulate(res.begin(), res.end(), 0);
}
\end{lstlisting}

这段程序首先初始化树的根节点为1，然后遍历AB串，针对连续A或者B的情况，程序进入else分支，它进一步以类似广度优先的形式遍历上层树的所有节点，
从每个值为i的节点，通过调用insertRange()子程序分支出1...i的子节点。如果不是连续A或B的情况变化，则程序进入if的分支，它进一步遍历上层
树的所有节点，从每个值为i的节点，分支出从当前树的深度（也就是AB串的当前长度）n, n-1, ...一共i个子节点。最后程序把树的最底层的所有叶子
节点值相加作为最终结果返回。

insertRange是一个辅助函数，它的功能就是生成从from到to的闭区间内的所整数值，并且from可以比to小。这一函数可以也使用STL标准库SGI实现中
的iota(发音为尤塔)函数\cite{sgiSTL},\cite{iota}.但是考虑到通用性，这里自己采用了自己的实现。

这段程序的调用及运行如下：
\begin{lstlisting}
int main(){
    cout<<"enum AAABBA="<<enumStr3("AAABBA")<<"\n";
}
\end{lstlisting}

\begin{verbatim}
enum AAABBA=50
\end{verbatim}

计算这一结果的Haskell程序，也非常直观，这里不再给出。请读者自行思考。

% ================================================================
%                 Others & summary
% ================================================================
\section{Other methods and Summary}
不枚举所有的排列而直接计算结果还有其他思路。Alecs King(alecs@perlchina.org)在TopLanguage讨论组给出了一个特别优美的实现

\begin{lstlisting}
get ab = sum $ foldl f [1] ab
    where f last 'A' = scanl (+) 0 last
          f last 'B' = scanr (+) 0 last 
\end{lstlisting}

%$
作为本文的结束，作者在此给出这个解法的一个简短分析。这一分析类似于数学归纳法，但是并不严格。

首先是平凡情况，如果AB串的长度为0,则符合条件的英文串只有一个，就是小写英文字母a；

如果长度为m的AB串，符合条件的英文串可以写成$x_1,x_2,x_3,...,x_{m+1}$的形式，
假设在这m+1个位置，放置第m+1个英文字母的方案数依次为：$n_1,n_2,n_3,...,n_{m+1}$。则符合要求的英文串总数就等于
$n_1+n_2+n_3+...+n_{m+1}$。
现在考虑长度为m+1的AB串，也就是在刚才长度为m的AB串后面，增加一条“前后规则”$X$，那么放置第m+2个英文字母的方案数可以这样求出：
\begin{itemize}
\item 如果$X=A$，也就是新字母要放在上一个字母的后面，首先考虑放在起始位置，显然这是不可能的，因为这样一来新字母就只可能处在上一字母的前面了；
再考虑左数第2位置，如果上一字母放在左数第1位置的方案数是$n_1$，则新字母放在第2位置的方案数也是$n_1$，因为只要把新字母紧接着上一个字母放就可以了；
再考虑左数第3位置，如果上一字母放在左数第2位置的方案数是$n_2$，则新字母放在第3位置的方案数就是是$n_1+n_2$，也就是上一字母放在第1，第2方案数的和；
...
所以总方案数为$0+n_1+(n_1+n_2)+(n_1+n_2+n_3)+...+(n_1+n_2+...+n_{m+1})$。
\item 如果$X=B$，也就是新字母要放在上一个字母的前面，首先考虑放在最右侧位置，显然这是不可能的，因为这样一来新字母就值可能处在上一字母的后面了；
再考虑右数第2位置，如果上一字母放在倒数第1位置的方案数是$n_{m+1}$，则新字母放在倒数第2位置的方案数也是$n_{m+1}$，因为只要把新字母紧接着放在上一个字母前就可以了；
分析基本同上，只不过要从右侧开始，所以所以总方案数为$(n_1+n_2+...+n_{m+1})+(n_1+n_2+...+n_m)+...+n_{m+1}+0$。
\end{itemize}
将这一分析翻译成Haskell就是上面的代码。

至此本文给出了解决这一问题的三种方法，其中第一种穷举法虽然效率很差，但是特别直观，可以用来验证其他方法的正确性；第二种生成法减少了计算的次数，但是仍然需要枚举出
所有的子方案。第三种方法通过展开方案树的形式，可以直接计算而不枚举方案。最后还给出了一种递推的思路。作者窃以为，解决了一个问题而并不满足，不断深入探索的过程特别
有意义，并且趣味性很强。同样语言本身的特性有时候能够帮助程序员从繁冗的部分解脱出来而把更多关注放在问题本身上。无论是C++标准库还是Haskell优雅的语用都有助于解题
的思维。由于作者水平有限，文中错误想必不少，还望读者批评指正。

\begin{thebibliography}{99}

\bibitem{kedama}
Oshima Yoshiki. Kedama: A massively-parallel tile-scriptable particle system. http://www.is.titech.ac.jp/~ohshima/squeak/kedama/

\bibitem{ao}
Liu Xinyu. 
\bibitem{kedama_cn}
，《程序设计中的组合数学》，清华大学出版社, Feb. 2001

\bibitem{AnnotatedSTL}
候捷，《STL源码抛析》，华中科技大学出版社，2002年6月

\bibitem{sgiSTL}
http://www.sgi.com/tech/stl/

\bibitem{iota}
http://www.knowledgerush.com/kr/encyclopedia/APL\_programming\_language/

\end{thebibliography}

\ifx\wholebook\relax\else
\end{document}
\fi
