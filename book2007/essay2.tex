\ifx\wholebook\relax \else
%-------------------------

\documentclass{article}
\input{common.tex}

\setcounter{page}{1}

\begin{document}

\fi

% ================================================================
%                 COVER PAGE
% ================================================================

\title{Lambda and high order function (II)\newline
       会当凌绝顶（下）}

\author{刘新宇
\thanks{{\bfseries Liu Xinyu } \newline
  5-2-201, ShiZiPo, Xi, DongZhiMenWai, DongCheng district, Beijing, 200027, P.R.China \newline
  Email: liuxinyu95@gmail.com \newline
  Tel:   +86-1305-196-8666 \newline
  Fax:   N.A. \newline}
  }


\markboth{Lambda and high order function (II), Feb. 2007}
{Lambda and high oder function (II), Feb. 2007}

\maketitle

\ifx\wholebook\relax
\chapter{Lambda and high order function (II)}
\section{abstruct}
\else
\begin{abstract}
\fi

什么是相等呢？古代形容一个学者成就大，叫做“著作等身”；50年代钱学森回国时，
五角大楼有人说他等于五个师。本文将谈到计算机程序中相等的概念。什么是计算呢？人头脑
中的计算和计算机中的计算有什么不同？计算的本质是什么呢？本文无法给出这些有趣
问题的正确答案，仅仅希望能够深入思考一下这些问题。并介绍一些前人的结果。

本文使用\LaTeXe排版，遵循FDL(GNU Free Documentation License)许可协议。
并受其保护。具体请参考：http://www.gnu.org/copyleft/fdl.html
由于作者水平有限，文中难免有谬误之处，欢迎广大读者指正！


\ifx\wholebook\relax\else
\end{abstract}
\fi

\vspace{3cm}
{\bfseries Keywords:} Equality, Church Number, Y combinator, C++

{\bfseries Created:} 2007 Feb.

\maketitle

\lstset{language=C++, 
  frame=single,
  showstringspaces=false, 
  breaklines=true, 
  breakautoindent=true}

% ================================================================
%                 Equality
% ================================================================
\section{Equality}
\label{equality}

\begin{verse}
三人同行七十希，五树梅花廿一支，\\
七子团员正半月，除百零五便得知。
\end{verse}
\begin{flushright}
――南宋，秦九韶\cite{hilbert}
\end{flushright}

\begin{figure}[htbp]
	\begin{center}
	\includegraphics{images/archimedes.eps}
    \caption{From http://maths.ilongman.com/Learning/story/story07.asp}
	\end{center}
\end{figure}

这首类似打油诗的口诀说得是数论中著名的“中国剩余定理”的一个例子。
不论是在古希腊，还是在古代中国，数学都是学者们感兴趣的内容。人们
从最初结绳记事，丈量土地开始，利用数学指导生产和生活。不同于其它
一些应用性学科，数学甚至还带有很强的哲学性质。

由于这一点，人们在深入思考事物本质的时候，也的深入思考着数学中一些
概念：什么是数？什么是计算？什么是相等？起源于数学的计算机科学，
在某种程度上就是在解答上面这些问题中产生并发展的。

在日常的计算机程序中，什么是相等呢？一般来说，在计算机程序中，通常
会判断变量与变量或者变量与值之间的相等。看一些简单的例子。

\begin{lstlisting}[frame=single]
int a=1;
int b=2;

if(a == b)
	std::cout<<"a is equal to b.\n";
else
	std::cout<<"a and b are not equal.\n";

if(a == 1)
	std::cout<<"a is equal to 1.\n";
else
	std::cout<<"a is not euqal to 1.\n";
\end{lstlisting}

对于a==b这个表达，可以粗略地认为相等的含义是a所代表的内存中的内容和
b所代表的内存中的内容一致。而对于a==1这个表达，可以认为相等的含义是
a所代表的内存中的内容是否是数字1。

除了这样的简单情况还有复杂情况。例如下面采用复合的方法定义了二维平面
上的点：

\begin{lstlisting}[frame=single]
class point{
public:
	point(int _x, int _y):x(_x), y(_y){}
	
	const int get_x() const { return x; }
	const int get_y() const { return y; }
private:
	int x;
	int y;
};
\end{lstlisting}

对于由简单物体复合而成的物体来说，相等的含义是什么呢？例如下面的测试
代码，返回的结果是p1和p2不相等：

\begin{lstlisting}[frame=single]
point* p1=new point(1,2);
point* p2=new point(1,2);

if( p1 == p2 )
	std::cout<<"p1 is equal to p2.\n";
else
	std::cout<<"p1 and p2 are not equal.\n";
\end{lstlisting}

虽然p1和p2都代表平面上横坐标为1，纵座标为2的点，但是p1==p2的含义和前面a==b
的含义一样――判断它们所代表内存中的内容是否一样。p1所代表的内存中的内容是一个地址，
其值引向了一块内存区，这块内存区内存储了一个横坐标为1，纵坐标为2的点，p2所
代表的内存中的内容是另外一个地址，期值指向了另外一块内存区，虽然这块内存区
保存的内容也是一个横坐标为1，纵坐标为2的点。由于p1和p2代表的内存中的内容是
不同的地址，所以认为它们不相等。

为了提取p1和p2代表内存中指向的内存区块，需要使用*p运算符，如下：

\begin{lstlisting}[frame=single]
if( *p1 == *p2 )
\end{lstlisting}

但是现代C++编译器针对这样的语句，会给出不知道如何比较两个点的错误。为此还需要
为point添加operator==()的定义。

\begin{lstlisting}[frame=single]
class point{
public:
	point(int _x, int _y):x(_x), y(_y){}
	const bool operator==(const point& p){
		return get_x() == p.get_x() && 
		       get_y() == p.get_y();
	}
	
	const int get_x() const { return x; }
	const int get_y() const { return y; }
private:
	int x;
	int y;
};

int main(int, char**){
	point* p1=new point(1,2);
	point* p2=new point(1,2);

	if( *p1 == *p2 )
		std::cout<<"p1 is equal to p2.\n";
	else
		std::cout<<"p1 and p2 are not equal.\n";
}
\end{lstlisting}

这样程序就可以输出正确的结果，认为p1和p2相等，都是一个横坐标为1，
纵座标为2的点。

但是，同样是代表横坐标为1，纵座标为2的点，另外一个程序为了支持彩色，
还定义了点的颜色，那么就无法使用上面的程序简单判断这两个点
是否相等。同样，还有一个程序，为了节省空间，没有使用int，而是使用
了short来代表x或y，也同样不能直接使用上面的程序来判断相等。

为此，不得不使用抽象概念定义平面上的点相等的含义：
\begin{center}
{\em 平面上的点相等，当且仅当其横座标和纵座标相等}
\end{center}

这个概念忽略了点的颜色，和座标的类型。可以把上述三种点都拿来进行相
等比较。其对应的相等判断程序如下：

\begin{lstlisting}[frame=single]
template<class T, class U>
const bool is_equal_point(T& p1, U& p2){
	return p1.get_x() == p2.get_x() &&
	       p1.get_y() == p2.get_y();
}
\end{lstlisting}

使用这个符合二维平面点相等定义的判断函数，就可以混合比较各种二维
平面上的点是否相等了，例如：

\begin{lstlisting}[frame=single]
class color_point{
public:
	enum { r, g, b};
	color_point(int x, int y, int c):_p(x, y), color(c){}

	const int get_x() const { return _p.get_x(); }
	const int get_y() const { return _p.get_y(); }
private:
	point _p;
	int color;
};

//...

color_point p3(1, 2, color_point::r);
point p4(1, 2);

if( is_equal_point(p3, p4) )
	std::cout<<"p3 is equal to p4.\n";
else
	std::cout<<"p3 and p4 are not equal.\n";
\end{lstlisting}

表面看起来不错，但是下面这个比较奇怪的“东西”也能通过比较，被认为是相等的二维
平面的点。

\begin{lstlisting}[frame=single]
struct CreatePoint{
	CreatePoint(int x, int y){
		f=lambda(arg(_x), body(If(eq(_x, 0)).Then(x).Else(y)));
	}
	const int get_x() { return f(0); }
	const int get_y() { return f(1); }
private:
	typedef IfOp<BinaryOp<Var<1>, int, Eq>, int, int> FunctionType; //(*)
	FunctionType f;
};

//...

if( is_equal_point(p4, CreatePoint(1, 2)) )
	std::cout<<"p4 is equal to CreatePoint(1, 2).\n";
\end{lstlisting}

从语义上讲，这段程序并没有产生一个具有“点”的含义的复合数据。
通常一个点的复合数据会包含两个基本数据，一个代表横座标x，另一个代表
纵座标y。但是上面的CreatePoint程序在语义上，通过使用lambda演算，
创建了一个名叫f的函数，而没有创建复合数据。获取横坐标纵坐标的方法
就是分别用0和1调用该函数。但是，用于判断相等的测试程序根本
无法分别出它究竟是一个复合数据，还是一个函数。

%labmda if then的实现
在继续探讨程序和数据的混淆的问题前，这里还要澄清上面程序中的if-then-else
是如何在lambda中实现的。

if-then-else不同于前面介绍的二元运算functor，它在某种意义上说是一种三元
运算，其根据if后面判断的情况返回then表达式或者返回else表达式的值。

为此可以这样定义if-then-else的functor：

\begin{lstlisting}[frame=single]
template<class Predicate, class Consequent, class Alternative>
struct IfOp{
    IfOp(Predicate p, Consequent c, Alternative a): predic(p), conseq(c), alter(a){}

    // ex: f=If(_x==-1, 0, 1), f(-1) //==0
    template<class T>
    T operator()(T x1){
		int test = Eval<IsFunctor<Predicate>::value>::apply(predic, x1);
		if(test)
			return Eval<IsFunctor<Consequent>::value>::apply(conseq, x1);
		else
			return Eval<IsFunctor<Alternative>::value>::apply(alter, x1);
    }

private:
    Predicate  predic;
    Consequent conseq;
	Alternative alter;
};
\end{lstlisting}

这段程序定义了IfOp三元运算functor，其中三个子运算functor分别由predic, 
conseq和alter记录。当然它们也可能是基本数据而不是functor。一旦将来使用这个
IfOp作用于某个变量上，IfOp将先针对测试语句predic求值，若此值为真，
则针对conseq求值并返回，否则返回针对alter求值的结果。

这个IfOp使用起来非常的冗长，为此仿照以前针对plus的办法，可以利用helper
函数来简化它的使用。但是不同于plus，if后面由于还有then以及else所以
需要一组helper来完成全部工作。下面是一个参考实现，读者也可以从附录
下载全部源代码。

\begin{lstlisting}[frame=single]
template<class Predicate, class Consequent>
struct ThenHelper{
	ThenHelper(Predicate p, Consequent c): predic(p), conseq(c){}

	template<class T>
	IfOp<Predicate, Consequent, T> Else(T x){
		return IfOp<Predicate, Consequent, T>(predic, conseq, x);
	}

	Predicate predic;
	Consequent conseq;
};

template<class Predicate>
struct IfHelper{
	IfHelper(Predicate p):predic(p){}

	template<class T>
	ThenHelper<Predicate, T> Then(T x){
		return ThenHelper<Predicate, T>(predic, x);
	}

	Predicate predic;
};

template<class T>
IfHelper<T> If(T x){
	return IfHelper<T>(x);
}
\end{lstlisting}

用户首先可以用一个测试表达式调用If()函数。该函数返回一个IfHelper，接着
可以调用IfHelper的Then()函数，根据C++语法，这两步调用可以合并写在一行，
形如If(...).Then(...)，Then()函数会接着返回一个ThenHelper，然后在
针对其调用Else()。就形成了前面CreatePoint中非常简洁的调用形式。

CreatePoint中的if表达式中，还有一eq()表达式，其本质是一个二元functor，
实现方法和plus一样，这里不再赘述，读者可以参考附录的例子程序。

%//(*)的冗长问题。
在CreatePoint程序中，标注有//(*)的一行非常冗长，并且难于理解。这一行实际
定义了lambda表达式的类型，由于C++是静态强类型语言，因此必须为f显示定义
类型。类型系统是一把双刃剑，在高阶应用的场合反而成为了一种阻碍。
\footnote{未来的C++标准在考虑是否将RTTI加强，这样就可以使用typeid(x)来判断
x的类型。目前G++最新版本的编译器已经扩充了类似的功能。这是解决lambda表达式
冗长类型的一种方法。}

为了在本文后继部分避免类似问题，一些动态语言（动态类型甚至无类型）如Lisp
方言Scheme的部分代码会用来举例说明。

% ================================================================
%                 Church Number
% ================================================================
\section{Church Number}
\label{church_num}
前面一节展示了这样一种情形：一个良好定义的程序无法分辨它所操作的内容究竟是
一组数据还是一段代码。这自然而然产生了一个疑问：“究竟谁更本质？
是数据还是函数？”\footnote{这里“函数”的意义，并非C++语言中函数的含义，而是
更加接近“功能”或者“程序”的概念。}

有些读者也许觉得这个问题十分可笑？尤其是联想到汇编语言，在计算机中，一切都
不过是二进制数据的表示，包括操作也都是二进制指令的表示。当然数据才是本质了。

但是，如果更深入考虑这个问题，就会产生迷惑，在计算机中二进制数究竟是什么？
是高低电平？高低电平靠什么来实现？靠晶体管逻辑电路的功能\dots 这样下去是
一连串“先有鸡还是先有蛋”的问题。

在二十世纪三十年代，为了表达计算，科学家们给出了一系列计算模型，其中有图灵(Alan, Turing)
给出的图灵机，也有邱奇(Alonzo, Church)给出的Lambda演算，并且在后来发现，
科学家们给出的众多计算模型都是等价的。从而最终导致了“邱吉――图灵论题”\cite{lambda}。

回到前面究竟谁更本质的问题，由于刚才提到的计算模型都是等价的\footnote{或称为图灵完备的}。
一个有趣思考就是，在一台只有Lambda而没有数的计算机上，如何表现0, 1, 2, \dots 
这些数字呢？

如果能够用某种方式表示0, 然后将加1的操作表示为某种变换（函数），就可以
在0上面不断地进行加1操作，从而获得1, 2, 3, \dots 为此邱奇给出了0的定义：

\be
 0 = (\lambda_f . (\lambda_x. x))
\ee

这个定义，如果在Lisp方言Scheme中可以表达为\cite{sicp}：

\lstset{language=lisp}
\begin{lstlisting}
(define zero (lambda (f) (lambda (x) x)))
\end{lstlisting}
\lstset{language=c++}

为了方便读者理解，上述Lisp语句可以表示为如下伪C++代码
\begin{lstlisting}
#define zero lambda(arg(f), 
         body( lambda(arg(x), body(x)) ))
\end{lstlisting}

这个数字0的定义，到底是什么含义呢？根据lambda的含义，数字零肯定是一个函数，
为了方便理解，不妨记该函数的名字为zero，该函数接受一个自变量$f$，对自变量
“运算”后，其返回值是另外一个函数，不妨记为zero-ret，于是：

\begin{verbatim}
zero-ret == zero(f)
\end{verbatim}

这个zero-ret由于用lambda定义，所以也是一个函数，它接受一个自变量$x$，
返回值也是$x$。因此：

\begin{verbatim}
zero-ret(x) == x
\end{verbatim}

也就是：
\begin{verbatim}
zero(f)(x) == zero-ret(x) == x
\end{verbatim}

所以用一句话来概括零的定义是：“函数$f$对参数$x$不起作用”，或着更明确地说：“函数
$f$对参数$x$起{\em 零}作用”

有了0的含义，就可以自然联想到1的含义：“函数$f$对参数$x$起一次作用”，于是1可以定义为：

\be
 1 = (\lambda_f . (\lambda_x. f(x)))
\ee

类似地，2定义为：
\be
 2 = (\lambda_f . (\lambda_x. f(f(x))))
\ee

也就是：“函数$f$对参数$x$起两次作用”。

\dots

数字$n$定义为：
\be
 n = (\lambda_f . (\lambda_x. f(f \cdots f(x)) \cdots ))
\ee

也就是：“函数$f$对参数$x$起$n$次作用”。所以自然数$n$是一个高阶函数,
当它作用于自变量$f$，然后再作用于自变量$x$时，可表示为:

\be
 n(f(x))
 \label{n-def}
\ee

这样，利用不完全归纳法，给出了一个自然数的定义\footnote{确切说是邱奇数的定义。}，
这和刚才提到的，只用0的定义和加1的操作就可以定义出全部自然数，尚有区别。
不过根据猜想到的数字$n$的定义，可以很快写出加1的操作了。

\be
 next = (\lambda_n . (\lambda_f. (\lambda_x. f (n f x) ) ) )
\ee

对应的Lisp方言Scheme中表示为：
\lstset{language=lisp}
\begin{lstlisting}
(define (next n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
\end{lstlisting}
\lstset{language=c++}

为了方便理解，相应的C++伪代码为：
\begin{lstlisting}
#define next lambda( 
		arg(f), 
		body( lambda( 
				arg(x), 
				body( f(n(f(x))) 
			))))
\end{lstlisting}

下面解释一下加1的含义，根据自然数$n$的定义，可以推断加1操作是令函数$f$对参数$x$
起作用的次数增加一次。若原来起$n$次作用，则加1操作后，会起$n+1$次作用。
根据公式\ref{n-def}，next(n)可以表示为：

\be
 next(n) ==> next(n)_{(f)(x)} = next(n(f(x))) = f(n(f(x)))
\ee

根据lambda的含义，可以推断next一定是一个函数，其接受一个自变量$n$（实际是一个函数
），返回值也是一个函数（不过这个函数实际表达的是一个自然数$n+1$）
不妨记其返回值的函数名为next-ret于是:

\begin{verbatim}
 next-ret = next(n)
\end{verbatim}

next-ret也是一个函数，其接受一个自变量$f$，返回值是另一个函数，不妨记为func-ret,于是

\begin{verbatim}
 func-ret = next-ret(f)
\end{verbatim}

func-ret仍然是一个函数，其接受一个自变量$x$，返回值是$f(n(f(x)))$，既：
\begin{verbatim}
 func-ret(x) = next-ret(f)(x) 
 = next(n)(f)(x) = next(n(f(x)) = f(n(f(x)))
\end{verbatim}

为了证明这个加1能够工作，利用数学归纳法，只需要证明下面两个命题就可以了：

\begin{enumerate}
\item 0加1等于1；
\item $n$加1等于$n+1$。
\end{enumerate}

读者不妨把此作为练习，并尝试给出加法的lambda定义\cite{lambda}。

通过上述方法，邱奇给出了完全通过lambda演算定义出的基本数字系统和在其上的各种操作。
后来人们称前面给出的数字定义为：“邱奇数”。

% ================================================================
%                 Y combinator
% ================================================================
\section{Y combinator} \label{ycombinator}

邱奇数极其在其上的各种算术操作构成了基本的计算模型。但是从这个计算模型出发，
构筑更为复杂的计算功能时却仍然有一些难题需要解决。尽管已经可以将数字，和加、减、
乘、除等操作表达为lambda演算。但是如何表达循环操作呢？（例如C++语言中的for, while
等）

在一门没有循环语句的语言中，循环可以采用递归来实现。例如下面的两段C++代码都可以
用来计算阶乘，但是后一段代码没有采用任何循环语句：

\begin{lstlisting}
int faction(int n){
	int res=1;
	for(int i=1; i<=n; ++i)
	    res*=i;
	return res;
}

int faction2(int n){
	if(n=0)
		return 1;
	else
		return n*faction2(n-1);
}
\end{lstlisting}

由此可以看到，递归是实现循环的一种方式。事实上，循环可以完全由递归来表达。但是递归
可以由Lambda来表达么？更为直观的说法是，如果某个计算机语言系统中，不但没有提供while,
for这样的循环语句，而且也不提供函数定义语句，程序员不能够像下面这样：

\begin{verbatim}
<func-name>(<arg list>){
 ...
}
\end{verbatim}

定义函数，有没有可能仅仅利用lambda和基本算术系统，实现一个类似阶乘似的复杂功能？

为了由浅入深给出利用lambda实现递归的方法，不妨仍然从阶乘开始，由内到外逐步去除所有
函数的引用和定义。

首先针对,faction2中的else一句，可以将其引用的函数（其自身）改为一个参数传入，于是
这段程序变为如下伪代码：

\begin{lstlisting}
int faction3(int n, function f){
	if(n=0)
		return 1;
	else
		return n*f(n-1);
}
\end{lstlisting}

这样，只要调用时，令faction3的第二个参数f仍然为faction3，就可以达到递归调用的效果，
调用方法大致如下:

\begin{lstlisting}
int res=faction3(6, faction3); //(**)
\end{lstlisting}

但是用(**)一句调用时，会发生一个错误。因为，从faction3的定义看出，其接受两个自变量，
是一个二元函数，其中一个自变量是一个整数n，代表要计算的n的阶乘，另外一个自变量是一个
函数f，在faction3的else子句中，会使用它。因此，若把faction3自身当作f传入的话，在
执行到else子句的f(n-1)时，就会发生参数不匹配的错误。因为f要求接受两个参数。

为此，需要修改faction3的else子句，将其变成如下的形式:

\begin{lstlisting}
int faction4(int n, function f){
	if(n=0)
		return 1;
	else
		return n*f(n-1, f);
}
\end{lstlisting}

这样，就消除了上述的参数个数不匹配错误。但是这段伪代码还无法运行，为此稍微进行修改，如下：

\begin{lstlisting}[frame=single]
#include <iostream>

typedef int (*F)(int, int);

int faction(int n, int f){
    if(n == 0)
        return 1;
    else
        return n* reinterpret_cast<F>(f)( n-1, f);
}

int main(int, char**){
    std::cout<<"6!="<<faction(6, reinterpret_cast<int>(faction))<<"\n";
}
\end{lstlisting}

这段程序会输出：
\begin{verbatim}
6!=720
\end{verbatim}

C++的类型系统再次成了实现的阻碍，因此不得不采用reinterpret\_cast的办法，这在如Lisp方言
Scheme的实现中，就会自然得多，下面给出的是对应的Scheme代码：

\lstset{language=lisp}
\begin{lstlisting}[frame=single]
(define faction
  (lambda(f n)
    (if (= n 1)
    	1
	(* n (f f (- n 1))))))
\end{lstlisting}
\lstset{language=c++}

现在只要再前进一步，将内层的部分改用lambda定义:

\begin{lstlisting}
faction5=lambda( arg(n, f), body( 
    If(n=0).Then(1).Else(n*f(n-1, f)) 
));
\end{lstlisting}

但是faction5接受两个参数，调用方式和最终的阶乘函数毕竟不同，为此可以再一次把调用
faction5的语句也封装起来，最终做成一个接受一个整数参数的阶乘，如下：

\begin{lstlisting}
int faction6(int x){
    faction5=lambda( arg(n, f), body(
        If(n=0).Then(1).Else(n*f(n-1, f))
    ));
    caller = lambda( arg(n, fact), body( fact(n, fact) ));
    return caller(x, faction5);
}
\end{lstlisting}

利用lambda的定义进而可以把faction6的中间变量faction5和caller都去掉，
于是：

\begin{lstlisting}
faction7=lambda( arg(n), body(
    lambda( arg(fact), body( fact(n, fact) ))(
        lambda( arg(n, f), body(
            If(n=0).Then(1).Else(n*f(n-1, f))
        ))
    )
));
\end{lstlisting}

于是，最后一步，干脆可以把faction7全部去掉，直接用如下语句计算6的阶乘：
\begin{lstlisting}
lambda( arg(n), body(
    lambda( arg(fact), body( fact(n, fact) ))(
        lambda( arg(n, f), body(
            If(n=0).Then(1).Else(n*f(n-1, f))
        ))
    )
))(6);
\end{lstlisting}

这样连续经过一系列变换，不知不觉间，已经仅仅使用Lambda实现了递归的阶乘运算。
现在，可以回顾前面的变换过程，分析究竟在哪一步，实现了计算的递归。这种分析
的重要性在于，希望从阶乘的具体问题抽象出递归的方法，并且能够推广到其他的具体
问题。

为此需要从最终结果中将阶乘相关的特殊内容，分离出去。可以看到function5是最接近
普通阶乘函数的一个中间结果，但是区别在于它{\em 同时}接受两个参数。

从lambda的定义可以直接发现，一个有趣性质，既由lambda定义的多元函数，可以通过
若干个由lambda定义的一元函数加以表示。如：

\bean
g=\lambda_{(x, y)} . f(x,y) = \lambda_x . (\lambda_y. f(x, y)) \\
g(x, y) = g(x)(y)
\eean

这个性质说明，同时使用所有参数对多元函数进行的调用，可以通过依次传递一个参数的
串行调用代替。这样就可以将faction5中的f和n不同时传入，先传入f，（f一旦确定faction5(f)就
成了一个关于n的一元函数）再传入n。这样改写后，faction5变成：

\begin{lstlisting}
faction8(function f){
    return lambda( arg(n, f), body( 
        If(n=0).Then(1).Else(n*(f(f))(n-1))))
}
\end{lstlisting}

可以通过faction8(faction8)(6)来计算6的阶乘。但是进一步可以发现，
其中的f(f)是一个细节，与阶乘本身无关，所以不妨用另外一个名称f1代替。于是变为：

\begin{lstlisting}
faction-only(function f1){
    return lambda( arg(n, f), body( 
        If(n=0).Then(1).Else(n*f1(n-1))))
}
\end{lstlisting}

但是这个改动造成了使用faction-only(faction-only)(6)的调用错误，
因为递归的细节f(f)被从faction-only
中去掉了。为此必须在调用的时候把这个递归的环节补偿上。方法是将仅仅与递归相关
的部分抽象概括出来。形成一个调用函数：

\begin{lstlisting}
faction9(function f2){
    return lambda( arg(n), body(
        fact-only(f2(f2))(n)));
}
\end{lstlisting}

这个函数的使用方式是：faction9(faction9)(6)。这样就可以求出6的阶乘。但是这些
伪代码无法被验证，为此可以利用它们的等价的Lisp方言Scheme代码：

\lstset{language=lisp}
\begin{lstlisting}
(define (fact-only f1)
  (lambda (n) (if (= n 1) 1 (* n (f1 (- n 1))))))

(define (fact9 f2)
  (lambda (n) ((fact-only (f2 f2)) n)))
\end{lstlisting}
\lstset{language=c++}

运行((fact9 fact9) 6)会返回720，验证了上述变换的正确性。fact9已经初步分离了
递归和阶乘两部分的内容。针对任何其他具体的问题，只要写一个函数，代替fact-only
就可以依然使用fact9来实现递归。但是为了获得更通用的递归能力，把fact-only作为
一个参数f传入，就比较理想了。为此变换为如下形式：

\begin{lstlisting}
faction9a(function f){
    faction9(function x){
        return lambda( arg(n), body(
            f(x(x))(n)));
    }
    return faction9(faction9);
}
\end{lstlisting}

faction9a距离最终分离出递归的lambda表达式非常接近。只要将其内部的faction9翻译
为lambda演算，并替换到return子句中就完成了。最终结果是：

\begin{lstlisting}
Y=lambda( arg(f), body(
   lambda( arg(x), body( lambda( arg(n), body(f(x(x))(n)))))
   lambda( arg(x), body( lambda( arg(n), body(f(x(x))(n)))))
  ))
\end{lstlisting}

既然这个lambda表达式完全与阶乘无关，而代表了递归，索性就命名为Y。为了最终确认
Y的正确性，可以用下面的等价Lisp代码来测试：
\lstset{language=lisp}
\begin{lstlisting}
(define Y
  (lambda (f)
    (
     (lambda(x) (lambda (n) ((f (x x)) n)))
     (lambda(x) (lambda (n) ((f (x x)) n))))))
\end{lstlisting}
\lstset{language=c++}

运行((Y fact-only) 6)，程序返回720说明结果正确。

% ================================================================
%                 Summary
% ================================================================
\section{Summary} \label{summary}

回顾本文的上半部分，从最简单最直观的程序出发，最终介绍了Y组合子。尽管最后一节
比较晦涩，但这正是以往众多科学家们留给后人的宝藏。本文远远不能介绍他们伟大努力
的万分之一。读者可以思考更多有趣的问题，这里不妨列举几个：
\begin{enumerate}
\item 如何仅仅使用Lambda实现减1操作？
\item 如何仅仅使用Lmabda实现布尔运算和if分支？本文给出的If().Then().Else()毕竟使用了C++中的if关键字，如何摆脱它？
\item Y的含义极其丰富，例如它具有这样的性质Y(f) = f(Y(f))，数学上称Y为f的不动点，请读者自行尝试，利用Y的定义证明这个等式。为方便证明，可以使用Y的一般形式\cite{fixpoint}：$\lambda_f. (\lambda_x. f(x x))(\lambda_x. f(x x))$。
\end{enumerate}

在本文的写作中，CSDN上的若干文章\cite{lambda_csdn}, \cite{pongba}起了相当重要的参考。之所以在这里不惜东施效颦，主要是考虑给出另外一种思路，也就是由浅入深，从现在追溯到过去的方法。希望能够对读者有所帮助。

% ================================================================
%                 Appendix
% ================================================================
\section{Appendix} \label{appendix}
本文使用的所有程序，都可以在这里\url{http://liuxinyu95.googlepages.com/book2007_example.zip}下载，其中lambda.h可以作为一个轻量级的lambda库使用。
lambda.cpp包括测试代码，展示了如何使用这个lambda库。Lisp方言Scheme代码y.scm可以在plt 
scheme上通过，稍作改动后可以在MIT scheme上运行。


\begin{thebibliography}{99}

\bibitem{hilbert}
胡久稔《希尔伯特第十问题》，辽宁教育出版社，1987年

\bibitem{lambda}
Wikipedia, ``Lambda calculus." 2006, June. \\ http://en.wikipedia.org/wiki/Lambda\_calculus

\bibitem{sicp}
Harold Abelson and Gerald Jay Sussman with Julie Sussman. ``Structure and Interpretation of Computer Programs." second edition. The MIT Press.

\bibitem{fixpoint}
Wikipedia, ``Fixed point combinator." 2007, Feb. \\http://en.wikipedia.org/wiki/Fixed\_point\_combinator

\bibitem{lambda_csdn}
g9，``负暄琐话." \\http://blog.csdn.net/g9yuayon/ http://blog.csdn.net/g9yuayon/category/16773.aspx

\bibitem{pongba}
刘未鹏, ``康托尔、哥德尔、图灵――永恒的金色对角线." 2006, Oct. \\http://blog.csdn.net/pongba/archive/2006/10/15/1336028.aspx

\end{thebibliography}

\ifx\wholebook\relax\else
\end{document}
\fi
