\documentclass[twocolumn]{article}
%\documentclass{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------

\usepackage{graphicx, color}		%for graph support
\usepackage{CJK}			%for Chinese support
%\usepackage{tex4ht}		%for LaTex --> HTML support
%\usepackage{hyperref}

% ========================= for programming ===========================
\usepackage{verbatim}
\usepackage{listings}
\lstloadlanguages{C++, lisp}
\lstset{showstringspaces=false, breaklines=true, 
	tabsize=4, keepspaces=true,
	basicstyle=\footnotesize, 
	showspaces=false,
	breakindent=4em,
	breakautoindent=true}
% ======================================================================

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\newtheorem{theorem}{Theorem}
\setcounter{page}{1}

% ====================Macros==========================

\newcommand{\be}{\begin{equation}}
\newcommand{\ee}{\end{equation}}
\newcommand{\bmat}[1]{\left( \begin{array}{#1} }
\newcommand{\emat}{\end{array} \right) }
\newcommand{\VEC}[1]{\mbox{\boldmath $#1$}}

% numbered equation array
\newcommand{\bea}{\begin{eqnarray}}
\newcommand{\eea}{\end{eqnarray}}

% equation array not numbered
\newcommand{\bean}{\begin{eqnarray*}}
\newcommand{\eean}{\end{eqnarray*}}

\begin{document}

% ======================CSDB editor comments===========================
%刘新宇:你好!
%
%            接到你朋友转来的一篇稿子,我们觉得可用(当然,这是初审),不过要你做一些修改
%把来稿的上部形成一篇文章,主要侧重在C++中使用boost库,这个点上,所以建议把高阶函数
%的一些内容取掉,简略地讲一下,就可以,作为后面引出lambda的铺垫.如下,是我建议修改的
%内容,尽快改完,寄给我,最好在周四以前能给我.
%
%        另杜甫的诗,是否能换一首,我觉得这是一个小技巧,而那首诗有些托大了.
%
%赵健平.
%
%
%题目:lambda与boost库的应用
%
%1问题:
%2高阶函数:
% 使用2.2
% 取掉2.1.2.3
%3lambda:
%4how to implement:
%
% ===================================================================

% ================================================================
%                 COVER PAGE
% ================================================================

\begin{CJK*}{GBK}{song}
\title{Lambda 和高阶函数 (I)}

\author{刘新宇
\thanks{{\bfseries 刘新宇 } \newline
  5-2-201, ShiZiPo, Xi, DongZhiMenWai, DongCheng district, Beijing, 200027, P.R.China \newline
  Email: liuxinyu95@gmail.com \newline
  Tel:   +86-1305-196-8666 }
  }


\markboth{Lambda and high order function, Jan, 2007}
{Lambda and high oder function, Jan, 2007}

%\date{Tokyo Institute of Technology\\
%4259 Nagatsuta, Midori-ku, Yokohama, Kanagawa 226-8502, Japan
%}

\maketitle
\end{CJK*}

\begin{abstract}
\begin{CJK*}{GBK}{song}
简单重复是人们最不喜欢的一件事情，《摩登时代》中的大机器流水线能够很快使一
个正常人疯狂――简单的重复劳动就是其中的原因之一。消除重复的手段之一就是制造
工具，让工具来代替人，去应对重复的工作。在软件开发中，抽象就是一种工具。
每向上抽象一个层次，就如同“更上一层楼”，眼前的景观会豁然开朗。本文就通过
分析日常开发中琐碎的代码，不断抽象，给出高阶函数和Lambda的概念。

由于作者水平有限，文中难免有谬误之处，欢迎广大读者指正！
\end{CJK*}
\end{abstract}

\begin{CJK*}{GBK}{song}
\vspace{3cm}
{\bfseries Keywords:} Lambda, High oder function, C++

\maketitle
\end{CJK*}

% ================================================================
%                 Introduction
% ================================================================
\section{Introduction}
\label{introduction}

\begin{CJK*}{GBK}{song}

孔子登东山而晓鲁，登泰山而晓天下。平日生活在城市水泥森林中的人，举目只能看到“咫尺蓝天”。编写程序也是如此，如果终日沉浸于代码，就难免“学而不思则罔”。本文将从极为熟悉的日常程序开始，通过不断抽象提高，尝试从代码的“森林”中走出来。
\end{CJK*}

\begin{CJK*}{GBK}{song}
首先看三段比较常见的代码\cite{sicp}：
\end{CJK*}

\lstset{language=C++}
%\lstset{backgroundcolor=\color{yellow}}
\begin{lstlisting}[frame=single]
int sumInt(int a, int b){
	int res=0;
	for(int i=a; i<=b; ++i)
		res+=i;
	return res;
}

int sumCube(int a, int b){
	int res=0;
	for(int i=a; i<=b; ++i)
		res+= i*i*i;
	return res;
}

double sumPi(int a, int b){
	double res=0;
	for(int i=1; i<=b; i+=4)
		res+= 1/(static_cast<double>(i)*static_cast<double>(i+2));
	return res;
}
\end{lstlisting}

\begin{CJK*}{GBK}{song}
这三个函数表面不同，然而形式上却极为相似。好像填词，虽然是不同的内容，只要词牌一样，就有一致的形式。看到“明月几时有，把酒问青天”，知道是《水调歌头》，看到“才饮长沙水，又食武昌鱼”也知道是《水调歌头》。

这三段程序都是用来求累加，它们分别计算如下的序列的和：

\be
  1+2+3+\ldots = \sum_{i=1}^n i \label{sum-int}
\ee
\be
  1^3+2^3+3^3+\ldots = \sum_{i=1}^n i^3 \label{sum-cube}
\ee
\be
  \frac{1}{1 \cdot 3} + \frac{1}{5 \cdot 7} + \frac{1}{9 \cdot 11} + \ldots = \sum_{i=1}^n \frac{1}{(2i-1)(2i+1)} \label{sum-pi}
\ee

并且其中第3个序列会收敛到$\pi/8$。

对于计算机程序，这种类似还不仅仅停留在形式上，类似意味着抽象，意味着一旦加以归纳，以后就可以不必重复劳动，意味着减小了重复工作中出现错误的风险。为此将上述代码抽象为如下形式：

\begin{lstlisting}[frame=single]
<sum-func>(<a>, <b>){
	res(0);
	for(i=a; i<=b; <next>(i))
		res+=<func>(i);
	return res;
}
\end{lstlisting}

凡是涉及与问题具体相关的部分都用$<>$包括起来，这样的统一形式显然不能直接工作，最多可以作为一个copy-past用的模板。而这样依然不能保证减小重复工作中出现错误的风险。为此可以设法将其抽象为合法的C++代码。这里的难点在于，型别的不确定性，在抽象阶段还无法确定$<a>$和$<b>$的型别以及$<sum-func>$和$<func>$返回值的型别。C++作为静态强类型语言，其型别系统也是一个双刃剑。某些情况下在动态类型语言中看似简单的功能，在强型别系统中却难以实现。对于当前的问题，暂时可以使用C++模板对型别加以抽象，如下：

\begin{lstlisting}[frame=single]
template<class T, class F, class G>
T sumGeneric(T a, T b, F func, G next){
	T res(0);
	for(T i=a; i<=b; next(i))
		res += func(i);
	return res;
};
\end{lstlisting}

这段代码，允许用户将循环体内计算的过程func()和用于从a向b前进的过程next()以参数的形式传递进入程序，然后按照抽象的形式加以计算。这种参数传递不关心func()和next()的具体类型。只要他们能够以函数的形式加以调用就可以\footnote{这里并不严格地做了一种类型上的假设：输入参数a和b以及该程序的返回值是同一种类型。这一假设在这里可以简化程序的实现，但是并不通用。}。这种方式正是Andrei在《Modern C++ Design》中给出的Plocy based programming概念\cite{moderncpp}。

既然该通用的加法程序不关心func和next的类型，只要他们能够以func(x)和next(x)的形式加以调用就可以。因此就可以采用非常轻量级的方法实现它们，传统的方法是使用函数指针，当然也可以采用C++提供的functor。下面是针对本文最开始列出的三段代码所实现的功能，给出的一些具体实现。他们都是functor。

\begin{lstlisting}[frame=single]
template<class T>
struct Self{
	T operator()(T x) { return x; }
};

template<class T>
struct Cube{
	T operator()(T x) { return x*x*x; }
};

template<class T>
struct MyFunc{
	T operator()(T x){
		return 1/(x*(x+2));
	}
};

template<class T>
struct Inc{
	void operator()(T& x){ ++x;}
};

template<class T>
struct Inc4{
	void operator()(T& x){ x+=4;}
};
\end{lstlisting}

这些实现中，Self, Cube和MyFunc，都是对自变量x的某种变换，其中Self不对自变量x做任何改变而直接返回x；Cube返回自变量x的三次方；而MyFunc会将自变量x和x+2相乘后取倒数。Inc和Inc4不同于前三个函数，他们会改变x的值。所有这些函数单元都不关心自变量的具体类型。

通过上述抽象后，就可以对比一下使用泛化的累加函数的效果，测试代码如下：

\begin{lstlisting}[frame=single]
std::cout<<"===trivial func calls===\n";
std::cout<<"sum int 1..100="<<sumInt(1, 100)<<"\n";
std::cout<<"sum cube 1..100="<<sumCube(1, 100)<<"\n";
std::cout<<"sum to PI 1..100="<<8.0*sumPi(1, 100)<<"\n";

std::cout<<"===high order sum calls===\n";
std::cout<<"sum int 1..100=" <<sumGeneric(1, 100, Self<int>(), Inc<int>())<<"\n";
std::cout<<"sum cube 1..100="<<sumGeneric(1, 100, Cube<int>(), Inc<int>())<<"\n";
std::cout<<"sum to PI 1..100="<<8.0*sumGeneric(1.0, 100.0, MyFunc<double>(), Inc4<double>())<<"\n";
\end{lstlisting}

上面这段程序会输出：
\begin{verbatim}
===trivial func calls===
sum int 1..100=5050
sum cube 1..100=25502500
sum to PI 1..100=3.12159
===high order sum calls===
sum int 1..100=5050
sum cube 1..100=25502500
sum to PI 1..100=3.12159
\end{verbatim}

可见，通用的累加函数可以达到同样的效果。但是却更加灵活了。用户可以根据自己的要求，方便的写出$<func()>$和$<next()>$。然后以参数的形式传递给sumGeneric，从而达到自己的要求。在数学上，通常称这种以其它函数作为自变量的函数，（也就是函数的函数）为高阶函数\footnote{这里叙述的是一种不严格的定义，读者可以参考泛函分析的书籍了解严密的定义}。

在本文的后继内容中，将在第\ref{highorderfunc}节中，进一步介绍高阶函数。然后在第\ref{lambda}节中找出存在的问题。为了解决这些问题，本节还会引出lambda演算的概念，并给出一个作者独立
实现的Lambda作为结尾。
\end{CJK*}

% ================================================================
%                 High order function
% ================================================================
\section{High order function}
\label{highorderfunc}

\begin{CJK*}{GBK}{song}
高阶函数不仅仅可以用在上面的场合中，对于编译期编程（模板推导，也就是所谓的template meta programming）也可以使用。由于不能定义任何编译期变量，所以是一种纯函数式的编程\cite{scheme_cpp}。下面的两段程序分别在编译期处理两种不同的累加：
\end{CJK*}

\begin{lstlisting}[frame=single]
template<int a, int b>
struct SumInt{
	static const int value = a + SumInt< a+1, b>::value;
};

template<int b>
struct SumInt<b, b>{ static const int value = b; };

template<int a, int b>
struct SumCube{
	static const int value = a*a*a + SumCube< a+1, b>::value;
};

template<int b>
struct SumCube<b, b>{ static const int value = b*b*b; };
\end{lstlisting}

\begin{CJK*}{GBK}{song}
由于编译期编程的判断语句主要通过模板偏特化进行实现，所以SumInt和SumCube分别定义了累加用的出口。
采用下面的调用方法，就可以输出和前面同样的结果：

\begin{lstlisting}[frame=single]
std::cout<<"sum int 1..100="<<SumInt<1, 100>::value<<"\n";
std::cout<<"sum cube 1..100="<<SumCube<1, 100>::value<<"\n";
\end{lstlisting}

对于这类编译期程序，也可以进一步抽象，定义高阶累加程序，为此把上面两段非常类似的代码中共通的部分概括起来，就得到了下面的高阶函数代码：

\begin{lstlisting}[frame=single]
template<int a, int b, template<int> class Func>
struct SumGeneric{
	static const int value = Func<a>::value + SumGeneric< a+1, b, Func>::value;
};

template<int b, template<int> class Func>
struct SumGeneric<b, b, Func>{ static const int value = Func<b>::value; };
\end{lstlisting}

为了使用这个编译期高阶过程，还必须提供处理自然数相加和自然数平方相加的函数，作为Func注入SumGeneric中。

\begin{lstlisting}[frame=single]
template<int x>
struct SelfTrans{
	static const int value = x;
};

template<int x>
struct CubeTrans{
	static const int value = x*x*x;
};
\end{lstlisting}

这两个函数都非常简单，调用时，只要把SelfTrans和CubeTrans作为第三个模板参数传入即可，调用代码如下：
\begin{lstlisting}[frame=single]
std::cout<<"sum int 1..100="<<SumGeneric<1, 100, SelfTrans>::value<<"\n";
std::cout<<"sum cube 1..100="<<SumGeneric<1, 100, CubeTrans>::value<<"\n";
\end{lstlisting}

运行结果也是5050和25502500。

简单看来，高阶函数好像仅仅是一组类似函数的抽象。但是在某些场合下，只有利用高阶函数才能完成相应的功能。例如假设需要通过利用累加的数值计算方法实现定积分的计算。这一计算过程可以表达如下：
\end{CJK*}

\bea
  && \int_a^b f(x) dx  \nonumber_ \\
  && = f(a)dx + f(a+dx)dx + f(a+2dx)dx + \cdots \nonumber \\
  && = [f(a) + f(a+dx) + f(a+2dx)]dx
\eea

\begin{CJK*}{GBK}{song}
其中dx是某一非常小的分隔距离，利用前面的高阶函数可以方便的实现定积分的数值计算。
方法是将next定义为每次前进dx，
func实现为被积函数，上下限分别对应a和b。例如下面的程序实现了一个积分函数。
\end{CJK*}

\begin{lstlisting}[frame=single]
template<class Func>
double integral(Func f, double a, double b, double dx){
	struct Inc_dx{
		Inc_dx(double dx):_dx(dx){}
		void operator()(double& x){
			x+=_dx;
		}
	private:
		double _dx;
	};
	return dx*sumGeneric(a, b, f, Inc_dx(dx));
}
\end{lstlisting}

\begin{CJK*}{GBK}{song}

这个函数接受4个参数，被积函数f,积分上下限a和b，以及分隔区间dx。该函数内部首先定义了一个局部functor\footnote{目前的C++各个实现中，对函数作用域内部的类或者内部类模板的支持不尽相同，有些C++中尚且不能实现类似Lisp方言Scheme中的内部环境，因此在这类环境中，Inc\underline{ }dx()无法直接访问dx，为此本例中采用带参数的构造函数方法，将dx传入其中。}，
名字叫Inc\underline{ }dx()，然后integral调用sumGeneric将积分计算出来。
下面是采用此积分程序计算$xdx$和$x^3dx$以及$sin(x)dx$定积分的实例：

\begin{lstlisting}[frame=single]
struct Sin{
	double operator()(double x){ return sin(x); }
};
const double PI=3.1415927;

std::cout<<"Int xdx (0~4)= 0.5x^2 (0~4)="<<integral(Self<double>(), 0.0, 4.0, 0.001)<<"\n";
std::cout<<"Int x^3dx (0~4)= 0.25x^4 (0~4)="<<integral(Cube<double>(), 0.0, 4.0, 0.001)<<"\n";
std::cout<<"Int sin(x)dx (0~pi/2)= "<<integral(Sin(), 0.0, PI/2, 0.001)<<"\n";
\end{lstlisting}

由于这几个积分非常简单，因此可以方便验证程序输出的正确与否：
\begin{verbatim}
Int xdx (0~4)= 0.5x^2 (0~4)=8.002
Int x^3dx (0~4)= 0.25x^4 (0~4)=64.032
Int sin(x)dx (0~pi/2)= 0.999704
\end{verbatim}

\end{CJK*}

% ================================================================
%                 Lambda
% ================================================================
\section{Lambda} \label{lambda}

\begin{CJK*}{GBK}{song}
高阶函数，虽然进行了一定程度的抽象，但仍然存在一些问题。为了使用高阶函数，用户不得不提供自己的Inc, Inc4, Self, Cube和MyFunc，明显可以看出这样的functor数量众多，内容简单，分布于程序的各处，并且不易维护；有时甚至很难命名\footnote{例如MyFunc，读者看到这个名字根本无法想想它是干什么的，还不如干脆叫$1/(2n-1)(2n+1)$看起来明白}。这种functor爆炸的问题怎么解决？

由于高阶函数操作其他函数，
因此作为作为高阶函数参数的各种普通函数会分布于程序各处。这些普通函数由用户传给高阶
函数使用，他们通常小巧简单，但却数量众多。并且高阶函数越抽象，就越能覆盖更广的应用，
也就是能够操作更多的普通函数。

这里所说的普通函数，并不一定是C++语法上的函数，而是某种程序单元，它们可以是普通函数，
更多的情况下，以functor的形式出现。随着程序越来越复杂，各种普通函数会充斥在程序的
各个角落，变得不容易维护。

\end{CJK*}

\subsection{Minor improvement}

\begin{CJK*}{GBK}{song}
着手解决functor数量爆炸的问题，其中一个方法仍然是利用抽象，例如Inc(), Inc4()这两个函数，
仔细观察就会发现他们有许多相似之处。可以很轻易地将其参数化为如下的一个统一的functor：
\begin{lstlisting}[frame=single]
template<class T, int n=1>
struct Increase{
	void operator()(T& x){ x+=n; }
};
\end{lstlisting}

采用这个抽象后，以前分别使用Inc()和Inc4()的地方就可以统一使用Increase()，对后继维护来说，
也从维护两个小函数，减少为维护一个小函数。如下：
\begin{lstlisting}[frame=single]
std::cout<<"sum int 1..100=" <<sumGeneric(1, 100, Self<int>(), Increase<int>())<<"\n";
std::cout<<"sum cube 1..100="<<sumGeneric(1, 100, Cube<int>(), Increase<int>())<<"\n";
std::cout<<"sum to PI 1..100="<<8.0*
		   sumGeneric(1.0, 100.0, MyFunc<double>(), Increase<double, 4>())<<"\n";
\end{lstlisting}

但是这种改进，并不能本质上解决小函数爆炸的问题。有些小函数根本无须定义，直接在需要的地方写出函数体，
甚至比命名它还要有意义（如前面的MyFunc）。
\end{CJK*}

\subsection{The ultimate solution}

\begin{CJK*}{GBK}{song}
为了给出本质的解决方案，可以引入Lambda的概念。Lambda在最近数年中逐渐活跃并受到重视，
一些流行的语言先后加入了对Lambda演算的支持，例如python，例如C\#等等。实际上Lambda并不是什么新潮的东西，一些具有良好传统的语言如Lisp，
很早就开始大规模使用Lambda。Lambda演算\cite{lambda}由数理学家Alonzo Church在20世纪30
年代引入。它对函数式编程，特别是Lisp语言有着巨大的影响。并且在后来被发现与图灵机等价，从而成为计算机科学的奠基石。

Lambda的严格形式化定义可以参考\cite{lambda}，本文仅仅给出一个相对不严格的直观的解释\cite{sicp}。
Lambda可以表示为如下形式：

\be
(\lambda_{<formal-parameters>}. <body>)
\ee

由于计算机代码中，无法输入希腊字母，以及排版下标，所以Lambda演算可以用普通英文字母表示为\footnote{
考虑有相当数量的读者不一定懂得Lisp语言，本文没有采用Lisp的语法给出Lambda演算的例子，而采用了一种
伪代码的形式。了解Lisp语言的读者可以直接参考\cite{sicp}或者\cite{htdp}
}：

\begin{verbatim}
(lambda (<formal-parameters>). <body>)
\end{verbatim}

例如定义一个匿名函数，它接受一个自变量$x$，该函数将$x+2$，可以用lambda演算表达为：
\begin{verbatim}
(lambda (x). (x+2))
\end{verbatim}
而前面的MyFunc函数，可以直接用Lambda演算表达为：
\begin{verbatim}
(lambda (n). 1/((2*n-1)*(2*n+1)))
\end{verbatim}

有些读者难免问：“Lambda演算不过就是将函数名称变成Lambda而已么？”实际上Lambda演算的确是用来定义
函数，但是这个函数是“通过Lambda表达式匿名地定义的”，也就是函数没有名字，仅仅说明了函数会对其参数
进行什么操作。例如下面的函数调用是错误的：
\begin{verbatim}
(lambda (1))
\end{verbatim}
要想使用$x+2$这个函数，必须引入一个调用方式。假设函数$f(x)=x+2)$，普通情况下的调用方式是$f(1)$，而
使用lambda演算时要采用“左结合”的方式进行调用：
\begin{verbatim}
(lambda (x). (x+2))(1)
\end{verbatim}
事实上，甚至可以将Lambda演算的结果赋值给一个函数的名称，然后利用这个名称调用：
\begin{verbatim}
f=(lambda (x). (x+2))
f(1)
\end{verbatim}

有了Lambda演算为什么就能够解决前面叙述的小函数爆炸的问题呢？因为可以不在程序的开始部分定义众多的小函数，
而仅仅在使用高阶函数时，通过Lambda演算将匿名小函数传给高阶函数，从而实现原来的功能。例如下面的伪代码，
使用Lambda演算，实现$\pi/8$的计算：
\begin{lstlisting}[frame=single]
sumGeneric(
	1, 100, 
	lambda(n). 1/((2*n-1)*(2*n+1)),
	lambda(i). (i++)
	)
\end{lstlisting}

上述代码在使用高阶函数sumGeneric时，针对第三个参数，提供了一个匿名小函数，该函数将会针对自变量计算相邻
两个奇数乘积的倒数；针对第四个参数，也提供了一个匿名小函数，该函数将会将自变量的值增加1。

而计算$x^3$和$sin(x)$积分的例子则可以写为：
\begin{lstlisting}[frame=single]
integral(lambda(x). x*x*x, 0, pi/2, 0.001);
integral(lambda(x). sin(x), 0, 4, 0.001);
\end{lstlisting}

\end{CJK*}

\subsection{How to implement?}

\begin{CJK*}{GBK}{song}
既然引入Lambda可以带来这样的好处，如何在C++语言中实现Lambda呢？一个自然的想法是依赖编译器，如果编译器提供
对Lambda关键字以及语法的支持，自然是“善之善者也。”但是目前没有任何C++编译器，直接支持Lambda。标准委员会审慎
而严谨的工作会仔细讨论每个提议的必要性，从而维护C++语言的完整性相容性。套用“泛函”中的一个术语，任何“非正交”
的功能都不是一个最小完备的功能集合。

那么暂时就没有办法在C++中使用Lambda演算了么？一些具有创造性的工作采用了目前C++语言的特性，
提供了一定程度的Lambda实现。比较典型的是boost库的实现\cite{boost_book},\cite{boost}。例如下面
的代码使用了boost::lambda来实现一个匿名小函数：

\begin{lstlisting}[frame=single]
#include <vector>
#include <algorithm>
#include "boost/lambda/lambda.hpp"
#include "boost/lambda/bind.hpp"

int main() {
  using namespace boost::lambda;

  std::vector<int> vec(3);
  vec[0]=12;
  vec[1]=10;
  vec[2]=7;

 // Transform using a lambda expression
  std::transform(vec.begin(),vec.end(),vec.begin(),_1-=4);
}
\end{lstlisting}

注意到其中的transform一句，其中最后一个参数应该是一个functor, 使用了boost::lambda后，这个
functor以lambda表达式\_1-=4进行定义。在这里\_1相当于普通lambda表达式中的x，其确切名称是placeholder，
其含义是目前这个函数的自变量还不清楚，但是这个函数会将自变量减去4。

也就是说，boost::lambda中，不需要用户显示地写出lambda关键字，而是使用\_1、\_2……这样的占位符来
直接描述Lambda演算中的函数体。

boost库中的实现方法读者可以参考\cite{cppmeta}来了解。作者在这里给出一个独立思考出的实现，虽然
没有boost库看起来的强大。但是在语法上，实现了“前缀运算的lambda演算”。

在实现前，首先通过对几个问题的分析，寻找出思路。为此列出如下的几个问题：

\begin{enumerate}
\item 问题1：
首先面临的第一个问题是，执行如下lambda语句究竟得到了什么？

\begin{verbatim}
lambda <arg> <body>
\end{verbatim}

这个问题看似简单，但是要理解到足够程度却有一定困难。粗略回答是：“得到了一个函数”。
但是C++中函数都是通过代码静态定义的，而$<body>$部分的描述是动态的（需要通过组合，
嵌套得到的复杂表达式）。因此使用C++宏之类来实现lambda的方案就有相当的困难。

使用宏的方案虽然比较诱人，但是就地展开的一段函数代码是不能作为一个值传入高阶函数的。
这会引发C++编译错误。

所以$<body>$部分只能是一个“行为看起来像函数”的东西，也就是functor。lambda表达式中的
$<body>$是functor，而其本身又是由诸多元素组合而成（加减乘除等），由此推断，
这些元素也必然是functor。

\item 问题2：
用什么代表$<body>$中的变量？$<body>$可以是含有变量的表达式，例如\begin{verbatim}2*x+y-1\end{verbatim}
然后$<body>$这个functor可以作为一个二元函数使用，例如\begin{verbatim}<body>(1,2)\end{verbatim}

但是在functor组合过程中，显然不能使用C++的变量，因为C++的变量根本就不是一个functor。
于是得出结论：$<body>$中的变量也是functor，不过它们很特殊，它们可以将最后求值时的代换操作，
传播到$<body>$中的所有functor内。

\item  问题3：
用什么模型？最后使用\begin{verbatim}<body>(1, 2)\end{verbatim}
求值时，必须保证1传播到所有x的地方，2传播到所有y的地方，这显然是一种递归的操作。
所以模型是一种递归模型

\end{enumerate}

经过以上的分析，下面就可以开始着手进行实现，本文模仿TDD(Test Drivern Developing)的模式，
从简单到复杂一步一步解决问题。

\begin{enumerate}

\item 测试：首先来实现代表$<body>$中变量的functor，它们能够携带信息，传播进入其他functor内，
其他functor在寻找第$i$个变量时，就可以通过$var_i$的形式找到它。类似的测试代码如下：
\begin{lstlisting}[frame=single]
//test var<1>()(1, 2) = 1;
std::cout<<"var<1>()(1,2)="<<Var<1>()(1,2)<<std::endl;

//test var<2>()(1, 2) = 2;
std::cout<<"var<2>()(1,2)="<<Var<2>()(1,2)<<std::endl;
\end{lstlisting}

为此可以利用一个接受整数参数的模板来实现，如下
\footnote{这里有一个非常重要的假设：{\em
lambda表达式中的所有内容，类型都一致。}
本文暂时不处理$2.3+x*4$这样的整形、浮点型混合问题，读者可以自己思考如何解决此类问题。}：

\begin{lstlisting}[frame=single]
template<int n> struct Var;

template<> struct Var<1>{
    template<class T>
    T operator()(T a1, T a2){ return a1; }
};

template<> struct Var<2>{
    template<class T>
    T operator()(T a1, T a2){ return a2; }
};
\end{lstlisting}

实际上$Var<1>$的实例就是$<body>$中的$x$，$Var<2>$
的实例就是$y$，前者负责在众多参数中，提取出$x$，后者提取$y$。
\footnote{这里为了简单只支持2个参数。参数多到n个时的做法也可仿此实现。}

\item 测试：补充一个只有一个参数的简单情形：

\begin{lstlisting}[frame=single]
//test var<1>()(1)=1;
std::cout<<"var<1>()(1)="<<Var<1>()(1)<<std::endl;
\end{lstlisting}

这说明$<body>$是一个一元函数，实现这个功能只需要增加一个重载函数：

\begin{lstlisting}[frame=single]
template<> struct Var<1>{
    //...

    template<class T>
    T operator()(T a1){ return a1; }
};
\end{lstlisting}

\item 测试：下面前进一步，实现一个加法操作：
\begin{lstlisting}[frame=single]
std::cout<<"plus(var<1>, var<2>)(3, 4)="
<<plus(Var<1>(), Var<2>())(3, 4)<<std::endl;
\end{lstlisting}

一个自然的想法是写一个加法模板，其接受两个functor，实现如下：
\begin{lstlisting}[frame=single]
template<class Func1, class Func2>
struct Plus{
    Plus(Func1 f1, Func2 f2):_f1(f1),_f2(f2){}

    // ex: f=plus(_x, _y), f(1, 2)
    template<class T>
    T operator()(T x1, T x2){
        T x = _f1(x1, x2);
        T y = _f2(x1, x2);
        return x+y;
    }

private:
    Func1 _f1;
    Func2 _f2;
};
\end{lstlisting}

整个模板在构造时把$x$和$y$变量对应的functor保存起来。在将来调用时，
使用这两个functor分别传播x和y，然后相加即可。不过这个模板使用起来
比较不方便，例如：
\begin{lstlisting}[frame=single]
Var<1> x;
Var<2> y;
Plus<Var<1>, Var<2> > f(x, y);
f(1, 2);
\end{lstlisting}
为此可以增加一个helper函数，来方便构造加法functor，如下：
\begin{lstlisting}[frame=single]
template<class A1, class A2>
Plus<A1, A2> plus(A1 a1, A2 a2){
    return Plus<A1, A2>(a1, a2);
}
\end{lstlisting}
这样测试代码就完全可以通过了。

\item 测试：下面开发针对常量的加法，测试代码为：
\begin{lstlisting}[frame=single]
//test plus(1,2)() = 3;
std::cout<<"plus(1, 2)()="<<plus(1, 2)()<<std::endl;
\end{lstlisting}
由于最后的$<body>$ functor，不接受任何参数。所以可以通过为Plus模板增加
一个重载函数实现，如下：
\begin{lstlisting}[frame=single]
template<class Func1, class Func2>
struct Plus{
    Plus(Func1 f1, Func2 f2):_f1(f1),_f2(f2){}

    //...

    // ex: f=plus(1, 2), f()
    //means that _f1 & f2 are premiers
    Func1 operator()(){
        return _f1+_f2;
    }

private:
    Func1 _f1;
    Func2 _f2;
};
\end{lstlisting}

\item 测试：这次增加一些难度，加入一个变量。
\begin{lstlisting}[frame=single]
//test plus(var<1>, 3)(2) = 2+3 = 5;
std::cout<<"plus<var<1>, 3)(2)="
    <<plus(Var<1>(), 3)(2)<<std::endl;
\end{lstlisting}
正如注释所说明的，\_f1或者\_f2之一是一个基本类型。当然也不排除他们
都是一元functor的可能。直观的做法是再增加一个只接受一个参数的重载
版本。但是究竟\_f1是基本类型呢，还是\_f2是基本类型呢？如果\_f1是基本
类型，最终结果应该是：
\begin{verbatim}
_f1+_f2(x)
\end{verbatim}
反之就是：
\begin{verbatim}
_f2(x)+_f1
\end{verbatim}
如果他们都是一元函数，则结果是：
\begin{verbatim}
_f1(x)+_f2(x)
\end{verbatim}
但是C++的特性决定了，不能写出这样的语句：
\begin{lstlisting}[frame=single]
int a;
int b;
if(_f1 is preimers)
  a= _f1;
else
  a= _f1(x);

if(_f2 is preimers)
  b= _f2;
else
  b= _f2(x);

return a+b;
\end{lstlisting}

这是因为，如果\_f1真的是基本类型，则else一句在编译时会出现语法错误。
所以解决方案是，使用模板偏特化。

首先，利用Andrie的方法，构造基本类型列表\cite{moderncpp}：
\begin{lstlisting}[frame=single]
template<class T, class U>
struct TList{
    typedef T First;
    typedef U Rest;
};

typedef TList<int, 
    TList<long, 
        TList<char, 
            TList<float ..., Empty> > ... > Premiers;
\end{lstlisting}
然后编写一个编译期程序，用于判断某个类型是否是基本类型：
\begin{lstlisting}[frame=single]
template<class TypeList, class T> struct Find{
    static const int value = 1 + Find<typename TypeList::Rest, T>::value;
};

template<class T, class U> struct Find<TList<T, U>, T>{
    static const int value = 0;
};

template<class T> struct Find<Empty, T>{
    static const int value = -1000;
};

template<class Func> struct IsFunctor{
    static const bool value = Find<Premiers, Func>::value < 0;
};
\end{lstlisting}

其中Find程序利用递归的方法在类型列表中寻找某类型是否是存在，如果找到，
则返回一个非负整数（类型在列表中的下标），反之返回一个负数。

然后IsFunctor程序利用这个特点，判断某个类型是一个基本类型还是Functor。

此后就可以利用这两个程序，建立偏特化模板，处理一元Plus函数，偏特化的模板
名叫Eval,实现如下：
\begin{lstlisting}[frame=single]
template<bool isFunctor> struct Eval;

// f is a functor
template<> struct Eval<true>{
    template<class F, class T>
    static T apply(F f, T x){
        return f(x);
    }

    template<class F, class T>
    static T apply(F f, T x1, T x2){
        return f(x1, x2);
    }
};

// f is not a functor
//  ==>f is const premier value;
template<> struct Eval<false>{
    template<class F, class T>
    static T apply(F f, T x){
        return f;
    }
};
\end{lstlisting}
这个模板使用apply来将一个函数作用到其自变量上。对于基本类型的情况，
则直接返回基本类型的值。使用Eval后，原来的Plus模板改写如下：
\begin{lstlisting}[frame=single]
template<class Func1, class Func2>
struct Plus{
    Plus(Func1 f1, Func2 f2):_f1(f1),_f2(f2){}

    // ex: f=plus(_x, _y), f(1, 2)
    template<class T>
    T operator()(T x1, T x2){
        T x = IsFunctor<Func1>::value ? _f1(x1, x2) : x1;
        T y = IsFunctor<Func2>::value ? _f2(x1, x2) : x2;
        return x+y;
    }

    // ex: f=plus(_x, 1), f(2)
    template<class T>
    T operator()(T x1){
        T x = Eval<IsFunctor<Func1>::value>::apply(_f1, x1);
        T y = Eval<IsFunctor<Func2>::value>::apply(_f2, x1);
        return x+y;
    }

    // ex: f=plus(1, 2), f()
    //means that _f1 & f2 are premiers
    Func1 operator()(){
        return _f1+_f2;
    }

private:
    Func1 _f1;
    Func2 _f2;
};
\end{lstlisting}

\item 测试：下面基本是验证性测试了。试试复合表达式：
\begin{lstlisting}[frame=single]
//test plus(var<1>, plus(var<1>, 2)(1)= 1 + 1 + 2 = 4;
	std::cout<<"plus(var<1>, plus(var<1>, 2)(1)="
		<<plus(Var<1>(), plus(Var<1>(), 2))(1)<<std::endl;
\end{lstlisting}

程序已经不需要做任何改动和添加，就可以完成这个测试。

\end{enumerate}

前面的所有测试运行结果如下：
\begin{verbatim}
var<1>()(1,2)=1
var<2>()(1,2)=2
var<1>()(1)=1
plus(1, 2)()=3
plus(var<1>, var<2>)(3, 4)=7
plus<var<1>, 3)(2)=5
plus(var<1>, plus(var<1>, 2)(1)=4
\end{verbatim}

至此，plus就完成了。仿照plus，可以写出minus, times, divide等二元函数，
它们非常相似，所以可以采用Policy的方式，将运算符Op注入\cite{moderncpp}。
同理可以实现一元函数。这样就可以利用这些函数组合出Lambda表达式。

最终的lambda，不过是前面内容的语法糖衣，以方便读者理解和使用：

\begin{lstlisting}[frame=single]
#define _x Var<1>()
#define _y Var<2>()

struct Empty;

template<class A1, class A2>
int arg(A1 a1, A2 a2){ return 0; }

template<class A1>
int arg(A1 a1){ return 0; }

template<class T>
T body(T f){ return f; }

template<class T>
T lambda(int /*arg*/, T f){ return f;}
\end{lstlisting}

这个lambda的使用方式，更像lisp语言――它使用前缀运算表达式。而不是C++
语言的中缀运算表达式。例如：
\begin{verbatim}
(* 2 (+ x 1))
\end{verbatim}
而不是
\begin{verbatim}
2*(x+1)
\end{verbatim}
如果希望使用中缀表达式，可以通过重载全局operator+(), operator*()来实现。
读者可以自行尝试。
下面是一个使用本文给出的lambda演算，调用高阶函数的例子：
\begin{lstlisting}[frame=single]
template<class F>
int sum(int a, int b, F f){
  int res(0);
  for(int i=a; i<=b; ++i)
    res+=f(i);
  return res;
}

int main(int argc, char** argv){
  std::cout<<"[f(x)=2*(x+1)], f(1)+f(2)+...+f(100)="
    <<sum(1, 100, lambda(arg(_x), body(times(2, plus(_x, 1)))))<<"\n";
}
\end{lstlisting}
程序输出：
\begin{verbatim}
[f(x)=2*(x+1)], f(1)+f(2)+...+f(100)=10300
\end{verbatim}

\end{CJK*}

% ================================================================
%                 Summary
% ================================================================
\section{Summary}
\begin{CJK*}{GBK}{song}
至此，本文从意义重复的程序出发，抽象出了高阶函数；进一步又从解决functor数量众多、难以
维护的问题前进，引出了lambda的概念，并独立给出了一个lambda的实现。这与其他lambda的实现，
例如\cite{lambda_cpp_more}相比，虽然在lambda的体部分，功能受限。但是由于其具有“值”的特性，因此可以直接作为一个部分嵌入到
表达式之中。

近百年来，科学家们在不断思索计算的问题。本文介绍的Lambda演算(邱奇，1936)就是这种努力之一。除此之外之外，图灵机(Alan, Turing 1936)、递归函数(哥德尔，赫尔布朗，克林)、波斯特系统(波斯特，1943)；马尔科夫算法(马尔科夫，1947)都是科学家们从完全不同的角度给出的计算模型，并且在后来发现，
科学家们给出的众多计算模型都是等价的\cite{hilbert}。从而最终导致了著名的“邱吉――图灵论题”\cite{lambda}。

由于作者水平有限，本文中错误想必比比皆是，还望读者批评指正。


\begin{thebibliography}{99}

\bibitem{sicp}
Harold Abelson and Gerald Jay Sussman with Julie Sussman. ``Structure and Interpretation of Computer Programs." second edition. The MIT Press.

\bibitem{moderncpp}
Andrei Alexandrescu, ``Modern C++ Design: Generic Programming and Design Pattern Applied." Addison Wesley, Feb. 2001

\bibitem{scheme_cpp}
Liu Xinyu, ``Scheme and C++ template." 2006, June. \\ http://baredog.at.infoseek.co.jp/intl/chn/softdev/book1/essay7.htm

\bibitem{lambda}
Wikipedia, ``Lambda calculus." 2006, June. \\ http://en.wikipedia.org/wiki/Lambda\_calculus

\bibitem{htdp}
Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, Shriram Krishnamurthi. ``How to Design Programs, An Introduction to Computing and Programming." The MIT Press, 2001

\bibitem{boost_book}
Bj\"{o}rn Karlsson. ``Beyond the C++ Standard Library: An Introduction to Boost." Addison Wesley Professional, August 31, 2005 

\bibitem{boost}
Boost C++ Libraries. http://www.boost.org/

\bibitem{cppmeta}
David Abrahams, Aleksey Gurtovoy. ``C++ Template Metaprogramming: Concepts, Tools, and Techniques from Boost and Beyond." Addison Wesley Professional, December 10, 2004.

\bibitem{lambda_cpp_more}
``Lambda abstractions in C++ vs. Scheme." http://okmij.org/ftp/c++-digest/Lambda-CPP-more.html

\bibitem{hilbert}
胡久稔《希尔伯特第十问题》，辽宁教育出版社，1987年

\end{thebibliography}

\end{CJK*}
\end{document}
