\ifx\wholebook\relax \else
% ------------------------

\documentclass[UTF8]{article}
%------------------- Other types of document example ------------------------
%
%\documentclass[twocolumn]{IEEEtran-new}
%\documentclass[12pt,twoside,draft]{IEEEtran}
%\documentstyle[9pt,twocolumn,technote,twoside]{IEEEtran}
%
%-----------------------------------------------------------------------------
\input{../../../common-zh-cn.tex}

\setcounter{page}{1}

\begin{document}

%--------------------------

% ================================================================
%                 COVER PAGE
% ================================================================

\title{AVL树}

\author{刘新宇
\thanks{{\bfseries 刘新宇} \newline
  Email: liuxinyu95@gmail.com \newline}
  }

\maketitle
\fi

\markboth{AVL树}{初等算法}

\ifx\wholebook\relax
\chapter{AVL树}
\numberwithin{Exercise}{chapter}
\fi

% ================================================================
%                 Introduction
% ================================================================
\section{简介}
\label{introduction} \index{AVL树}

\subsection{度量树的平衡性}

除了红黑树，还有没有其他自平衡二叉树呢？为了度量一棵二叉树的平衡，我们可以比较它左右分支的高度差，如果差很大，则说明树不平衡。定义一棵树的高度差如下：

\be
  \delta(T) = |L| - |R|
\ee

其中$|T|$代表树$T$的高度，$L$和$R$分别代表左右分支。

若$\delta(T) = 0$，说明树是平衡的。例如，一个高度为$h$的完全二叉树有$n = 2^h-1$个节点。除了叶子节点外，所有节点都含有两个非空的分支。完全二叉树就满足$\delta(T)=0$。另外一个特殊的例子是空树：$\delta(\phi) = 0$。通常$\delta(T)$的绝对值越小，说明树越平衡。

我们定义$\delta(T)$为一棵二叉树的\underline{平衡因子}。

% ================================================================
% Definition
% ================================================================
\section{AVL树的定义}
\index{AVL树!定义}

如果一棵二叉搜索树的所有子树都满足如下条件，我们称之为AVL树。

\be
  |\delta(T)| \leq 1
\ee

AVL树中所有子树平衡因子的绝对值都不大于1，只可能是-1、0，或1这三个值。图\ref{fig:avl-example}给出了一个AVL树的例子。

\begin{figure}[htbp]
   \centering
   \includegraphics[scale=0.5]{img/avl-example.ps}
   \caption{AVL树的例子} \label{fig:avl-example}
\end{figure}

为什么AVL树能保证树的平衡性呢？或者说为什么这个定义能保证一棵有$n$个节点的树的高度为$O(\lg n)$？我们可以用下面的方法来证明这一事实。

对于一棵高为$h$的AVL树，它的节点数目并不是一个固定的值。当它是一棵完全二叉树时，含有的节点数目最多，为$2^h-1$。那么它最少包含多少节点呢？我们记函数$N(h)$代表高度为$h$时，AVL树含有最少的节点数。对于简单的情况，我们可以立即给出$N(h)$的值：

\begin{itemize}
\item 空树，$h=0$，$N(0)=0$；
\item 只有一个根节点的树，$h=1$，$N(1)=1$；
\end{itemize}

一般情况下$N(h)$是怎样的呢？图\ref{fig:N-h-relation}中给出了一个高度为$h$的AVL树$T$。它包含三部份：根节点和左右两个分支$L$与$R$。树的高度和子树高度之间满足下面的关系：

\be
  h= max(|L|, |R|) + 1
\ee

因此，必然存在一个子树的高度为$h-1$。根据AVL树的定义，我们有 $||L| -|R|| \leq 1$。所以另外一棵子树的高度不会小于$h-2$。而$T$所包含的节点数为两个子树的节点数再加1（1个根节点）。于是我们得到下面的递归关系：

\be
  N(h) = N(h-1) + N(h-2) + 1
  \label{eq:Fibonacci-like}
\ee

\begin{figure}[htbp]
   \centering
   \includegraphics[scale=0.5]{img/Nh-lvr.ps}
   \caption{高度为$h$的AVL树，其中一个分支为$h-1$，另外一个分支的高度不小于$h-2$} \label{fig:N-h-relation}
\end{figure}

这一递归形式让我们联想起著名的斐波那契（Fibonacci）数列。如果定义$N'(h) = N(h)+1$，我们就可以将(\ref{eq:Fibonacci-like})转换成斐波那契数列。

\be
  N'(h) = N'(h-1) + N'(h-2)
\ee

\begin{lemma}
\label{lemma:N-phi}
定理：若$N(h)$表示高为$h$的AVL树的节点数目最小值，令$N'(h) = N(h) + 1$，则：

\be
  N'(h) \geq \phi^h
\ee

其中$\phi = \frac{\sqrt{5}+1}{2}$，通常被称为黄金分割比。
\end{lemma}

\begin{proof}
证明：使用数学归纳法。对于起始情况，我们有：
\begin{itemize}
\item $h=0$, $N'(0) = 1 \geq \phi^0 = 1$
\item $h=1$, $N'(1) = 2 \geq \phi^1 = 1.618...$
\end{itemize}

对于递推情况，设$N'(h) \geq \phi^h$。
\[
  \begin{array}{lll}
  N'(h+1) & = N'(h) + N'(h-1) & \{Fibonacci\} \\
          & \geq \phi^h + \phi^{h-1} & \\
          & = \phi^{h-1}(\phi + 1) & \{\phi + 1 = \phi^2 = \frac{\sqrt{5}+3}{2}\} \\
          & = \phi^{h+1}
 \end{array}
\]
\end{proof}

由定理\ref{lemma:N-phi}，我们立即得到下面的结果：

\be
  h \leq log_{\phi}(n+1) = log_{\phi}(2) \cdot \lg (n+1) \approx 1.44 \lg (n+1)
  \label{eq:AVL-height}
\ee

这一不等式说明AVL树的高度为$O(\lg n)$，从而保证了平衡性。

在树的基本操作中，插入和删除会改变树的结构。如果由此导致平衡因子的绝对值超过1，就需要通过修复使得$|\delta|$恢复到1以内。常见的修复方法是使用树旋转。受到Okasaki在红黑树\cite{okasaki}中的思路启发，本章中，我们介绍一种模式匹配（pattern matching）方法。这种“改变―恢复”的操作，使得AVL树成为了一种自平衡二叉树。作为比较，本章同样也给出命令式的AVL树算法。

平衡因子$\delta$显然可以通过递归求出。另外一种方法是在每个节点中保存一分平衡因子的值，如果树被改变，我们只要更新这个值就可以了。这一方法不需要每次都计算。

根据这一思路，我们在二叉搜索树的定义中增加一个$\delta$变量，如下面的C++代码所示\footnote{有些实现不保存$\delta$，取而代之保存树的高度，如\cite{py-avl}。}。

\lstset{language=C++}
\begin{lstlisting}
template <class T>
struct node{
  int delta;
  T key;
  node* left;
  node* right;
  node* parent;
};
\end{lstlisting}

某些纯函数式实现使用不同的constructor来保存平衡因子$\delta$。例如在\cite{hackage}中，定义了4个不同的constructor：\texttt{E}、\texttt{N}、\texttt{P}、\texttt{Z}。其中，\texttt{E}代表空树$\phi$；\texttt{N}代表平衡因子为-1；\texttt{P}代表平衡因子为1；\texttt{Z}代表平衡因子为0。

本章中，我们直接在节点中保存平衡因子的值。

\lstset{language=Haskell}
\begin{lstlisting}
data AVLTree a = Empty
               | Br (AVLTree a) a (AVLTree a) Int
\end{lstlisting}

不改变树的操作，包括查找，寻找最大、最小值和二叉搜索树完全一样。我们略过它们，仅仅关注哪些会改变树结构的操作。

% ================================================================
%                 Insertion
% ================================================================
\section{插入}
\index{AVL树!插入}

在AVL树中插入一个新元素可能造成AVL树的平衡性被破坏，平衡因子$\delta$的绝对值有可能超过1。为了恢复平衡，可以根据不同的插入情形进行树的旋转操作。大多数命令式实现采用这种方法。

另外一种方法很像Okasaki在红黑树实现中使用的模式匹配方法。它的特点是简单直观。

向AVL树中插入一个新key，根节点的平衡因子的\underline{变化}会在$[-1, 1]$之间\footnote{注意：这里不是说平衡因子的值在$[-1, 1]$内，而是说它的变化在这个范围内。}，树的高度最多增加1。我们需要递归地使用这一信息来更新其他层级上的平衡因子$\delta$。定义插入算法的结果为一对值$(T', \Delta H)$，其中$T'$为插入后的新树，$\Delta H$为树高度的增加值。令函数$first(pair)$可以取得一对值中的第一个元素。我们可以在二叉搜索树的插入算法上进行改动，定义AVL树的插入操作：

\be
insert(T, k) = first(ins(T, k))
\ee

其中

\be
ins(T, k) = \left \{
  \begin{array}
  {r@{\quad:\quad}l}
  ((\phi, k, \phi, 0), 1) & T = \phi \\
  tree(ins(L, k), k', (R, 0), \Delta) & k < k' \\
  tree((L, 0), k', ins(R, k), \Delta) & otherwise
  \end{array}
\right.
\label{eq:ins}
\ee

$L$、$R$、$k'$、$\Delta$的定义如下，它们分别表示左右子树，key和平衡因子。

\[
  \begin{array}{l}
  L = left(T) \\
  R = right(T) \\
  k' = key(T) \\
  \Delta = \delta(T)
  \end{array}
\]

向AVL树$T$中插入一个新key $k$时，如果树为空，结果为一个叶子节点，节点的key为$k$，平衡因子为0。树的高度增加1。

否则，如果$T$不为空，我们需要比较根节点的key k'和待插入key k的大小。如果$k$小于根节点的key，我们将其递归插入左子树，否则将其插入右子树。

我们前面定义了递归插入的结果为一对值，例如$(L', \Delta H_l)$。我们需要对插入的结果调整平衡，并更新高度的增加值。函数$tree()$被定义用来完成这一任务。它接受4个参数：$(L', \Delta H_l)$、$k'$、$(R', \Delta H_r)$和$\Delta$。这一函数的运算结果记为$(T', \Delta H)$。其中，$T'$为调整平衡后的树，$\Delta H$是树高度的增加值，定义如下：

\be
  \Delta H = |T'| - |T|
\ee

它可以进一步分解为4种情况。

\be
\begin{array}{rl}
  \Delta H & = |T'| - |T| \\
              & = 1 + max(|R'|, |L'|) - (1 + max(|R|, |L|)) \\
              & = max(|R'|, |L'|) - max(|R|, |L|) \\
              & = \left \{
                  \begin{array}{r@{\quad:\quad}l}
                  \Delta H_r & \Delta \geq 0 \land \Delta' \geq 0 \\
                  \Delta + \Delta H_r & \Delta \leq 0 \land \Delta' \geq 0 \\
                  \Delta H_l - \Delta & \Delta \geq 0 \land \Delta' \leq 0 \\
                  \Delta H_l & otherwise
                  \end{array} \right .
\end{array}
\ee

由于一次插入操作不可能同时增加左右分支的高度，因此我们可以做上述的情况分解。根据定义，平衡因子等于右子树的高度减去左子树的高度。这4种情况可以分别解释如下：

\begin{itemize}
\item 如果$\Delta \geq 0$并且$\Delta' \geq 0$。这说明在插入前后，右子树的高度都不小于左子树的高度。因子整个树高度的增加，全部“贡献”自右子树高度的变化$\Delta H_r$；

\item 如果$\Delta \leq 0$，说明在插入前，左子树的高度不小于右子树。但是插入后$\Delta' \geq 0$，说明右子树的高度由于插入操作增加了，而左子树的高度保持不变（$|L'|=|L|$）。所以高度的增加为：
\[
\begin{array}{rll}
\Delta H & = max(|R'|, |L'|) - max (|R|, |L|) & \{\Delta \leq 0 \land \Delta' \geq 0 \}\\
         & = |R'|-|L| & \{|L|=|L'| \}\\
         & = |R|+\Delta H_r - |L| & \\
         & = \Delta + \Delta H_r &
\end{array}
\]

\item 如果$\Delta \geq 0 \land \Delta' \leq 0$，和第二种情况类似，我们有：

\[
\begin{array}{rll}
\Delta H & = max(|R'|, |L'|) - max (|R|, |L|) & \{\Delta \geq 0 \land \Delta' \leq 0 \}\\
         & = |L'|-|R| & \\
         & = |L|+\Delta H_l - |R| & \\
         & = \Delta H_l - \Delta&
\end{array}
\]

\item 最后一种情况，$\Delta$和$\Delta'$都不大于0，说明插入前后左子树的高度都不小于右子树。所以高度的增加全部“贡献”自左子树的变化$\Delta H_l$。
\end{itemize}

在进行平衡调整前，我们还需要确定新的平衡因子$\Delta'$。根据AVL树平衡因子的定义，我们有：

\be
\begin{array}{rl}
\Delta' & = |R'| - |L'| \\
        & = |R| + \Delta H_r - (|L| + \Delta H_l) \\
        & = |R| - |L| + \Delta H_r - \Delta H_l \\
        & = \Delta + \Delta H_r - \Delta H_l
\end{array}
\ee

树高度的变化和平衡因子都准备好后，就可以定义(\ref{eq:ins})中的函数$tree()$了。

\be
tree((L', \Delta H_l), k', (R', \Delta H_r), \Delta) =
  balance ((L', k', R', \Delta'), \Delta H)
\ee

在具体解释平衡调整的细节前，我们可以先给出上述函数的Haskell例子代码。首先是插入函数：

\lstset{language=Haskell}
\begin{lstlisting}
insert t x = fst $ ins t where
    ins Empty = (Br Empty x Empty 0, 1)
    ins (Br l k r d)
        | x < k     = tree (ins l) k (r, 0) d
        | x == k    = (Br l k r d, 0)
        | otherwise = tree (l, 0) k (ins r) d
\end{lstlisting} %$

这段代码中，如果待插入的key已经存在，它仅仅使用新key覆盖原先的值。

\begin{lstlisting}
tree (l, dl) k (r, dr) d = balance (Br l k r d', delta) where
    d' = d + dr - dl
    delta = deltaH d d' dl dr
\end{lstlisting}

高度增加的计算函数定义如下：

\begin{lstlisting}
deltaH d d' dl dr
       | d >=0 && d' >=0 = dr
       | d <=0 && d' >=0 = d+dr
       | d >=0 && d' <=0 = dl - d
       | otherwise = dl
\end{lstlisting}

\subsection{平衡调整}
\index{AVL树!平衡调整}
我们准备使用模式匹配（pattern matching）来恢复平衡，首先需要考虑由哪些情况（pattern）会破坏AVL树的性质。

图\ref{fig:insert-fix}中展示了4种需要修复平衡的情况。这4种情况种，平衡因子都是2或者-2，而不在范围$[-1, 1]$之内。通过调整，平衡因子变成0，左右分支成为同样的高度。

\begin{figure}[htbp]
   \begin{center}
     \setlength{\unitlength}{1cm}
     \begin{picture}(15, 15)
        % arrows
        \put(4.5, 9.5){\vector(1, -1){1}}
        \put(4.5, 5){\vector(1, 1){1}}
        \put(10, 9.5){\vector(-1, -1){1}}
        \put(10, 5){\vector(-1, 1){1}}
        % delta values
        \put(5, 13){$\delta(z) = -2$}
        \put(2.5, 12){$\delta(y) = -1$}
        \put(10, 13){$\delta(x) = 2$}
        \put(11.5, 11.5){$\delta(y) = 1$}
        \put(1.5, 5.5){$\delta(z) = -2$}
        \put(3.5, 4){$\delta(x) = 1$}
        \put(12, 5.5){$\delta(x) = 2$}
        \put(10.5, 4){$\delta(z) = -1$}
        \put(7.5, 10){$\delta'(y) = 0$}
        % graphics
	\put(0, 7){\includegraphics[scale=0.5]{img/insert-ll.ps}}
        \put(0, 0){\includegraphics[scale=0.5]{img/insert-lr.ps}}
        \put(7, 7){\includegraphics[scale=0.5]{img/insert-rr.ps}}
        \put(8.5, 0){\includegraphics[scale=0.5]{img/insert-rl.ps}}
        \put(2, 5){\includegraphics[scale=0.5]{img/insert-fixed.ps}}
      \end{picture}
     \caption{插入后需要调整平衡的4种情况。} \label{fig:insert-fix}
  \end{center}
\end{figure}

我们从左上角开始，按照顺时针方向，依次称这4种情况为左－左偏（left-left lean）、右－右偏（right-right lean）、右－左偏（right-left lean）和左－右偏（left-right lean）。记调整前的平衡因子为$\delta(x)$、$\delta(y)$和$\delta(z)$；调整后的平衡因子为$\delta'(x)$、$\delta'(y)$和$\delta'(z)$。

我们解下来将证明，经过调整后，所有4种情况的平衡因子都变成$\delta(y)=0$。并且将给出调整后$\delta'(x)$和$\delta'(z)$的结果。

\subsubsection{左－左偏（Left-left lean）的情况}

由于$x$子分支在调整前后的结构维持不变，因此可以立即得到等式：$\delta'(x) = \delta(x)$。

因为$\delta(y) = -1$且$\delta(z) = -2$，所以：

\be
  \begin{array}{l}
  \delta(y) = |C| - |x| = -1 \Rightarrow |C| = |x| - 1 \\
  \delta(z) = |D| - |y| = -2 \Rightarrow |D| = |y| - 2
  \end{array}
  \label{eq:ll-cd}
\ee

调整平衡后：

\be
  \begin{array}{rll}
  \delta'(z) & = |D| - |C| & \{ From (\ref{eq:ll-cd}) \}\\
             & = |y| - 2 - (|x| - 1) & \\
             & = |y| - |x| - 1 & \{  x \text{ is child of } y \Rightarrow |y|-|x| = 1\} \\
             & = 0 &
  \end{array}
  \label{eq:ll-delta-z}
\ee

对于$\delta'(y)$，调整平衡后我们有如下结果：

\be
  \begin{array}{rll}
  \delta'(y) & = |z| - |x| & \\
             & = 1 + max(|C|, |D|) - |x| & \{ \text{By (\ref{eq:ll-delta-z}), we have} |C| = |D|\} \\
             & = 1 + |C| - |x| & \{ \text{By (\ref{eq:ll-cd})}\} \\
             & = 1 + |x| - 1 - |x| & \\
             & = 0 &
  \end{array}
\ee

汇总上述结果，对于左－左偏的情况，新的平衡因子如下：

\be
  \begin{array}{l}
  \delta'(x) = \delta(x) \\
  \delta'(y) = 0 \\
  \delta'(z) = 0
  \end{array}
\ee

\subsubsection{右－右偏（Right-right lean）的情况}

因为右－右偏和左－左偏对称，易知新的平衡因子结果如下：

\be
  \begin{array}{l}
  \delta'(x) = 0 \\
  \delta'(y) = 0 \\
  \delta'(z) = \delta(z)
  \end{array}
  \label{eq:rr-result}
\ee

\subsubsection{右－左偏（Right-left lean）的情况}

首先考虑$\delta'(x)$。调整平衡后，我们有：

\be
  \delta'(x) = |B| - |A|
  \label{eq:rl-dx}
\ee

调整平衡前，如果我们计算$z$的高度，有如下的结果：

\be
  \begin{array}{rll}
  |z| & = 1 + max(|y|, |D|) &  \{ \delta(z) = -1 \Rightarrow |y| > |D|\} \\
      & = 1 + |y| & \\
      & = 2 + max(|B|, |C|)
  \end{array}
  \label{eq:rl-z}
\ee

因为$\delta(x) = 2$，所以可以推出：

\be
  \begin{array}{rll}
  \delta(x) = 2 & \Rightarrow |z| - |A| = 2 & \{ \text{By (\ref{eq:rl-z})} \}\\
                & \Rightarrow 2 + max(|B|, |C|) - |A| = 2 & \\
                & \Rightarrow max(|B|, |C|) - |A| = 0 &
  \end{array}
  \label{eq:rl-ca}
\ee

如果$\delta(y) = 1$，也就是$|C| - |B| = 1$，则有下面的关系：

\be
  max(|B|, |C|)= |C| = |B|+1
\ee

将其代入式(\ref{eq:rl-ca})得到：

\be
  \begin{array}{ll}
  |B|+1-|A| = 0 \Rightarrow |B|-|A|= -1 & \{ \text{By (\ref{eq:rl-dx}) } \} \\
  \Rightarrow \delta'(x) = -1 &
  \end{array}
\ee

反之，如果$\delta(y) \neq 1$，则有$max(|B|, |C|) = |B|$，将其代入式(\ref{eq:rl-ca})得到：

\be
  \begin{array}{ll}
  |B| - |A| = 0  & \{ \text{By (\ref{eq:rl-dx})} \} \\
  \Rightarrow \delta'(x) = 0 &
  \end{array}
\ee

合并上述两种子情况，我们可以得到$\delta'(x)$和$\delta(y)$的关系：

\be
\delta'(x) = \left \{
  \begin{array}
  {r@{\quad:\quad}l}
  -1 & \delta(y) = 1 \\
  0 & otherwise
  \end{array}
\right.
\label{eq:rl-dx-dy}
\ee

对于$\delta'(z)$，根据定义，它等于：

\be
  \begin{array}{rll}
    \delta'(z) & = |D| - |C| & \{ \delta(z) = -1 = |D| - |y| \} \\
               & = |y| - |C| - 1 & \{ |y| = 1 + max(|B|, |C|) \} \\
               & = max(|B|, |C|) - |C|
  \end{array}
  \label{eq:rl-dz}
\ee

如果$\delta(y) = -1$，则有$|C| - |B| = -1$，所以$max(|B|, |C|) = |B| = |C| + 1$。将其代入式(\ref{eq:rl-dz})中，我们有：$\delta'(z) = 1$。

反之，如果$\delta(y) \neq -1$，则$max(|B|, |C|) = |C|$，我们有$\delta'(z)=0$。

合并上述两种子情况，$\delta'(z)$和$\delta(y)$的关系如下：

\be
\delta'(z) = \left \{
  \begin{array}
  {r@{\quad:\quad}l}
  1 & \delta(y) = -1 \\
  0 & otherwise
  \end{array}
  \right.
  \label{eq:rl-dz-dy}
\ee

最后，对于$\delta'(y)$，我们可以推导出下面的关系：

\be
  \begin{array}{rl}
  \delta'(y) & = |z| - |x| \\
             & = max(|C|, |D|) - max(|A|, |B|)
  \end{array}
  \label{eq:rl-dy}
\ee

这里又分为3种子情况：
\begin{itemize}

\item 若$\delta(y)=0$，说明$|B|=|C|$，根据式(\ref{eq:rl-dx-dy})和式(\ref{eq:rl-dz-dy})，我们有：$\delta'(x)=0 \Rightarrow |A| = |B|$以及$\delta'(z)=0 \Rightarrow |C|=|D|$。因此$\delta'(y)=0$。

\item 若$\delta(y)=1$，根据式(\ref{eq:rl-dz-dy})，我们有$\delta'(z)=0 \Rightarrow |C| = |D|$。

\[
  \begin{array}{rll}
  \delta'(y) & = max(|C|, |D|) - max(|A|, |B|) & \{|C|=|D|\} \\
             & = |C| - max(|A|, |B|) & \{\text{From (\ref{eq:rl-dx-dy}): $\delta'(x)=-1 \Rightarrow |B|-|A|=-1$} \} \\
             & = |C| - (|B| + 1) & \{ \delta(y) = 1 \Rightarrow |C|-|B|=1\} \\
             & = 0
  \end{array}
\]

\item 若$\delta(y)=-1$，根据式(\ref{eq:rl-dx-dy})，我们有$\delta'(x)=0 \Rightarrow |A|=|B|$。

\[
  \begin{array}{rll}
  \delta'(y) & = max(|C|, |D|) - max(|A|, |B|) & \{|A|=|B|\} \\
             & = max(|C|, |D|) - |B| & \{ \text{From (\ref{eq:rl-dz-dy}): $|D|-|C|=1$} \} \\
             & = |C| + 1 - |B| & \{  \delta(y) = -1 \Rightarrow |C|-|B|=-1\} \\
             & = 0
  \end{array}
\]

\end{itemize}

全部三种情况的结果都是$\delta'(y)=0$。

将上述结果归纳起来，可以得到新的平衡因子如下：

\be
  \begin{array}{l}
  \delta'(x) = \left \{
    \begin{array}
    {r@{\quad:\quad}l}
    -1 & \delta(y) = 1 \\
    0 & otherwise
    \end{array}
    \right. \\
  \delta'(y) = 0 \\
  \delta'(z) = \left \{
    \begin{array}
    {r@{\quad:\quad}l}
    1 & \delta(y) = -1 \\
    0 & otherwise
    \end{array}
    \right.
  \end{array}
  \label{eq:rl-result}
\ee

\subsubsection{左－右偏（Left-right lean）的情况}

左－右偏的情况和右－左偏的情况对称。使用类似的推导，我们可以得到和式(\ref{eq:rl-result})完全相同的结果。

\subsection{模式匹配}
各种修复平衡的情况可以抽象成模式，下面的函数使用模式匹配定义了平衡修复算法。

\be
balance(T, \Delta H) = \left \{
  \begin{array}
  {r@{\quad:\quad}l}
  (((A, x, B, \delta(x)), y, (C, z, D, 0), 0), 0) & P_{ll}(T) \\
  (((A, x, B, 0), y, (C, z, D, \delta(z)), 0), 0) & P_{rr}(T) \\
  (((A, x, B, \delta'(x)), y, (C, z, D, \delta'(z)), 0), 0) & P_{rl}(T) \lor P_{lr}(T) \\
  (T, \Delta H) & otherwise
  \end{array}
\right.
\ee

其中$P_{ll}(T)$表示树$T$满足左－左偏的情况。$\delta'(x)$和$delta'(z)$按照式(\ref{eq:rl-result})定义。

\be
\begin{array}{l}
P_{ll}(T) = (((A, x, B, \delta(x)), y, C, -1), z, D, -2) \\
P_{rr}(T) = (A, x, (B, y, (C, z, D, \delta(z)), 1), 2) \\
P_{rl}(T) = ((A, x, (B, y, C, \delta(y)), 1), z, D, -2) \\
P_{lr}(T) = (A, x, ((B, y, C, \delta(y)), z, D, -1), 2)
\end{array}
\ee

下面的Haskell例子代码实现了这一平衡修复函数。

\begin{lstlisting}
balance :: (AVLTree a, Int) -> (AVLTree a, Int)
balance (Br (Br (Br a x b dx) y c (-1)) z d (-2), _) =
        (Br (Br a x b dx) y (Br c z d 0) 0, 0)
balance (Br a x (Br b y (Br c z d dz)    1)    2, _) =
        (Br (Br a x b 0) y (Br c z d dz) 0, 0)
balance (Br (Br a x (Br b y c dy)    1) z d (-2), _) =
        (Br (Br a x b dx') y (Br c z d dz') 0, 0) where
    dx' = if dy ==  1 then -1 else 0
    dz' = if dy == -1 then  1 else 0
balance (Br a x (Br (Br b y c dy) z d (-1))    2, _) =
        (Br (Br a x b dx') y (Br c z d dz') 0, 0) where
    dx' = if dy ==  1 then -1 else 0
    dz' = if dy == -1 then  1 else 0
balance (t, d) = (t, d)
\end{lstlisting}

插入算法的性能和树的高度成正比，根据之前给出的证明，如果AVL树包含$n$个元素，插入算法的性能为$O(\lg n)$。

\subsubsection{验证}
\index{AVL tree!verification}

可以定义一个函数来检查一棵树是否是AVL树。我们需要验证两方面：首先它必须是一棵合法的二叉搜索树；其次它满足AVL树的性质。

我们略过二叉搜索树的检验，读者可以把它作为本章的一个练习题。

为了验证AVL树的性质是否满足，我们需要检查左右分支的高度差，然后再递归检查左右分支是否也满足AVL树的性质。直到最终到达叶子节点。

\be
  avl?(T) = \left \{
  \begin{array}
  {r@{\quad:\quad}l}
  True & T = \Phi \\
  avl?(L) \land avl?(R) \land ||R|-|L|| \leq 1 & otherwise
  \end{array}
  \right .
\ee

树的高度可以根据定义递归进行计算：

\be
  |T| = \left \{
  \begin{array}
  {r@{\quad:\quad}l}
  0 & T = \Phi \\
  1 + max(|R|, |L|) & otherwise
  \end{array}
  \right .
\ee

相应的Haskell例子程序实现如下：

\begin{lstlisting}
isAVL Empty = True
isAVL (Br l _ r d) = and [isAVL l, isAVL r, abs (height r - height l) <= 1]

height Empty = 0
height (Br l _ r _) = 1 + max (height l) (height r)
\end{lstlisting}

\begin{Exercise}
编写程序检查一棵二叉树是否是二叉搜索树。如果使用命令式（imperative）语言，请考虑如何消除递归。
\end{Exercise}



% ================================================================
%                 Deletion
% ================================================================

\section{删除}
\index{AVL树!删除}

As we mentioned before, deletion doesn't make significant sense in
purely functional settings. As the tree is read only, it's typically
performs frequently looking up after build.

Even if we implement deletion, it's actually re-building the tree
as we presented in chapter of red-black tree. We left the deletion
of AVL tree as an exercise to the reader.

\begin{Exercise}

\begin{itemize}

\item Take red-black tree deletion algorithm as an example, write the
AVL tree deletion program in purely functional approach in your
favorite programming language.

\item Write the deletion algorithm in imperative approach in your favorite
programming language.

\end{itemize}

\end{Exercise}

\section{Imperative AVL tree algorithm $\star$}
\index{AVL tree!imperative insertion}

We almost finished all the content in this chapter about AVL tree.
However, it necessary to show the traditional insert-and-rotate
approach as the comparator to pattern matching algorithm.

Similar as the imperative red-black tree algorithm, the strategy
is first to do the insertion as same as for binary search tree,
then fix the balance problem by rotation and return the final result.

\begin{algorithmic}[1]
\Function{Insert}{$T, k$}
  \State $root \gets T$
  \State $x \gets$ \Call{Create-Leaf}{$k$}
  \State \Call{$\delta$}{$x$} $\gets 0$
  \State $parent \gets NIL$
  \While{$T \neq NIL$}
    \State $parent \gets T$
    \If{$k <$ \Call{Key}{$T$}}
      \State $T \gets $ \Call{Left}{$T$}
    \Else
      \State $T \gets $ \Call{Right}{$T$}
    \EndIf
  \EndWhile
  \State \Call{Parent}{$x$} $\gets parent$
  \If{$parent = NIL$} \Comment{tree $T$ is empty}
    \State \Return $x$
  \ElsIf{$k <$ \Call{Key}{$parent$}}
    \State \Call{Left}{$parent$} $\gets x$
  \Else
    \State \Call{Right}{$parent$} $\gets x$
  \EndIf
  \State \Return \Call{AVL-Insert-Fix}{$root, x$}
\EndFunction
\end{algorithmic}

Note that after insertion, the height of the tree may increase, so that
the balancing factor $\delta$ may also change, insert on right side will
increase $\delta$ by 1, while insert on left side will decrease it. By
the end of this algorithm, we need perform bottom-up fixing from node $x$
towards root.

We can translate the pseudo code to real programming language, such as
Python \footnote{C and C++ source code are available along with this book}.
\lstset{language=Python}
\begin{lstlisting}
def avl_insert(t, key):
    root = t
    x = Node(key)
    parent = None
    while(t):
        parent = t
        if(key < t.key):
            t = t.left
        else:
            t = t.right
    if parent is None: #tree is empty
        root = x
    elif key < parent.key:
        parent.set_left(x)
    else:
        parent.set_right(x)
    return avl_insert_fix(root, x)
\end{lstlisting}

This is a top-down algorithm search the tree from root down to the proper
position and insert the new key as a leaf. By the end of this algorithm, it calls fixing procedure, by passing the root and the new node inserted.

Note that we reuse the same methods of set\_left() and set\_right() as
we defined in chapter of red-black tree.

In order to resume the AVL tree balance property by fixing, we first determine if the new node is inserted on left hand or right hand. If it is on left, the balancing factor $\delta$ decreases, otherwise it increases. If we denote the new value as $\delta'$, there are 3 cases of the relationship between $\delta$ and $\delta'$.

\begin{itemize}
\item If $|\delta| = 1$ and $|\delta'| = 0$, this means adding the new node makes the tree perfectly balanced, the height of the parent node doesn't change, the algorithm can be terminated.

\item If $|\delta| = 0$ and $|\delta'| = 1$, it means that either the height of left sub tree or right sub tree increases, we need go on check the upper level of the tree.

\item If $|\delta| = 1$ and $|\delta'| = 2$, it means the AVL tree property is violated due to the new insertion. We need perform rotation to fix it.
\end{itemize}

\begin{algorithmic}[1]
\Function{AVL-Insert-Fix}{$T, x$}
  \While{\Call{Parent}{$x$} $\neq NIL$}
    \State $\delta \gets $ \textproc{$\delta$}(\Call{Parent}{$x$})
    \If{$x = $ \textproc{Left}(\Call{Parent}{$x$})}
      \State $\delta' \gets \delta - 1$
    \Else
      \State $\delta' \gets \delta + 1$
    \EndIf
    \State \textproc{$\delta$}(\Call{Parent}{$x$}) $\gets \delta'$
    \State $P \gets $ \Call{Parent}{$x$}
    \State $L \gets $ \Call{Left}{$x$}
    \State $R \gets $ \Call{Right}{$x$}
    \If{$|\delta| = 1$ and $|\delta'| = 0$} \Comment{Height doesn't change, terminates.}
      \State \Return $T$
    \ElsIf{$|\delta| = 0$ and $|\delta'| = 1$} \Comment{Go on bottom-up updating.}
      \State $x \gets P$
    \ElsIf{$|\delta| = 1$ and $|\delta'| = 2$}
      \If{$\delta'=2$}
        \If{$\delta(R) = 1$} \Comment{Right-right case}
          \State $\delta(P) \gets 0$ \Comment{By (\ref{eq:rr-result})}
          \State $\delta(R) \gets 0$
          \State $T \gets $ \Call{Left-Rotate}{$T, P$}
        \EndIf
        \If{$\delta(R) = -1$} \Comment{Right-left case}
          \State $\delta_y \gets $ \textproc{$\delta$}(\Call{Left}{$R$}) \Comment{By (\ref{eq:rl-result})}
          \If{$\delta_y = 1$}
            \State $\delta(P) \gets -1$
          \Else
            \State $\delta(P) \gets 0$
          \EndIf
          \State \textproc{$\delta$}(\Call{Left}{$R$}) $\gets 0$
          \If{$\delta_y = -1$}
            \State $\delta(R) \gets 1$
          \Else
            \State $\delta(R) \gets 0$
          \EndIf
          \State $T \gets $ \Call{Right-Rotate}{$T, R$}
          \State $T \gets $ \Call{Left-Rotate}{$T, P$}
        \EndIf
      \EndIf
      \If{$\delta' = -2$}
        \If{$\delta(L) = -1$} \Comment{Left-left case}
          \State $\delta(P) \gets 0$
          \State $\delta(L) \gets 0$
          \State \Call{Right-Rotate}{$T, P$}
        \Else \Comment{Left-Right case}
          \State $\delta_y \gets $ \textproc{$\delta$}(\Call{Right}{$L$})
          \If{$\delta_y = 1$}
            \State $\delta(L) \gets -1$
          \Else
            \State $\delta(L) \gets 0$
          \EndIf
          \State \textproc{$\delta$}(\Call{Right}{$L$}) $\gets 0$
          \If{$\delta_y = -1$}
            \State $\delta(P) \gets 1$
          \Else
            \State $\delta(P) \gets 0$
          \EndIf
          \State \Call{Left-Rotate}{$T, L$}
          \State \Call{Right-Rotate}{$T, P$}
        \EndIf
      \EndIf
      \State break
    \EndIf
  \EndWhile
  \State \Return $T$
\EndFunction
\end{algorithmic}

Here we reuse the rotation algorithms mentioned in red-black tree chapter.
Rotation operation doesn't update balancing factor $\delta$ at all,
However, since rotation changes (actually improves) the balance situation
we should update these factors. Here we refer the results from above section. Among the four cases, right-right case and left-left case only need one rotation, while right-left case and left-right case need two rotations.

The relative python program is shown as the following.

\begin{lstlisting}
def avl_insert_fix(t, x):
    while x.parent is not None:
        d2 = d1 = x.parent.delta
        if x == x.parent.left:
            d2 = d2 - 1
        else:
            d2 = d2 + 1
        x.parent.delta = d2
        (p, l, r) = (x.parent, x.parent.left, x.parent.right)
        if abs(d1) == 1 and abs(d2) == 0:
            return t
        elif abs(d1) == 0 and abs(d2) == 1:
            x = x.parent
        elif abs(d1)==1 and abs(d2) == 2:
            if d2 == 2:
                if r.delta == 1:  # Right-right case
                    p.delta = 0
                    r.delta = 0
                    t = left_rotate(t, p)
                if r.delta == -1: # Right-Left case
                    dy = r.left.delta
                    if dy == 1:
                        p.delta = -1
                    else:
                        p.delta = 0
                    r.left.delta = 0
                    if dy == -1:
                        r.delta = 1
                    else:
                        r.delta = 0
                    t = right_rotate(t, r)
                    t = left_rotate(t, p)
            if d2 == -2:
                if l.delta == -1: # Left-left case
                    p.delta = 0
                    l.delta = 0
                    t = right_rotate(t, p)
                if l.delta == 1: # Left-right case
                    dy = l.right.delta
                    if dy == 1:
                        l.delta = -1
                    else:
                        l.delta = 0
                    l.right.delta = 0
                    if dy == -1:
                        p.delta = 1
                    else:
                        p.delta = 0
                    t = left_rotate(t, l)
                    t = right_rotate(t, p)
            break
    return t
\end{lstlisting}

We skip the AVL tree deletion algorithm and left this as an exercise to the reader.

\section{Chapter note}
AVL tree was invented in 1962 by Adelson-Velskii and Landis\cite{wiki},
\cite{TFATP}. The name AVL tree comes from the two inventor's name. It's earlier than red-black tree.

It's very common to compare AVL tree and red-black tree, both are self-balancing binary search trees, and for all the major operations, they both consume $O(\lg N)$ time. From the result of (\ref{eq:AVL-height}), AVL tree is more rigidly balanced hence they are faster than red-black tree in looking up intensive applications \cite{wiki}. However, red-black trees could perform better in frequently insertion and removal cases.

Many popular self-balancing binary search tree libraries are implemented on top of red-black tree such as STL etc. However, AVL tree provides an intuitive and effective solution to the balance problem as well.

After this chapter, we'll extend the tree data structure from storing data in node to storing information on edges, which leads to Trie and Patrica, etc. If we extend the number of children from two to more, we can get B-tree. These data structures will be introduced next.

\begin{thebibliography}{99}

\bibitem{hackage}
Data.Tree.AVL http://hackage.haskell.org/packages/archive/AvlTree/4.2/doc/html/Data-Tree-AVL.html

\bibitem{okasaki}
Chris Okasaki. ``FUNCTIONAL PEARLS Red-Black Trees in a Functional Setting''. J. Functional Programming. 1998

\bibitem{wiki}
Wikipedia. ``AVL tree''. http://en.wikipedia.org/wiki/AVL\_tree

\bibitem{TFATP}
Guy Cousinear, Michel Mauny. ``The Functional Approach to Programming''. Cambridge University Press; English Ed edition (October 29, 1998). ISBN-13: 978-0521576819

\bibitem{py-avl}
Pavel Grafov. ``Implementation of an AVL tree in Python''. http://github.com/pgrafov/python-avl-tree
\end{thebibliography}

\ifx\wholebook\relax\else
\end{document}
\fi

% LocalWords:  AVL Okasaki STL
